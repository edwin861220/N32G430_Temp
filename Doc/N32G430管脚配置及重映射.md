
# TIM1复用功能重映射

复用功能             管脚          重映射
TIM1_ETR            PA12          AF3
TIM1_CH1            PA8           AF3
                    PA0           AF10
                    PB14          AF10
TIM1_CH2            PA9           AF3    
                    PA8           AF8
TIM1_CH3            PA10          AF3
TIM1_CH4            PA7           AF2
                    PA11          AF3
                    PB6           AF7
                    PB9           AF10
TIM1_BKIN           PA10          AF2 
                    PA6           AF6
                    PB4           AF6
                    PB12          AF6
TIM1_CH1N           PA7           AF3
                    PA11          AF3
                    PB5           AF7
                    PB13          AF10
TIM1_CH2N           PB14          AF3 
                    PB0           AF6
                    PA6           AF2          
                    PB6           AF8
                    PB15          AF10
                    PD15          AF8
TIM1_CH3N           PB15          AF3 
                    PB1           AF6
                    PA9           AF2
                    PD14          AF2
TIM1_CH4N           PB2           AF6   
                    PB7           AF7
    
# TIM2复用功能重映射 

复用功能             管脚          重映射
TIM2_ETR            PA15          AF3
                    PA0           AF6
TIM2_CH1            PA0           AF3
                    PA15          AF6
TIM2_CH2            PA1           AF3    
                    PB3           AF3
TIM2_CH3            PB10          AF3
                    PA2           AF3
TIM2_CH4            PB11          AF3    

# TIM3复用功能重映射

复用功能             管脚          重映射
TIM3_ETR            PB2           AF13
TIM3_CH1            PA6           AF3
                    PB4           AF3
TIM3_CH2            PA7           AF3    
                    PB5           AF3
TIM3_CH3            PB10          AF3
TIM3_CH4            PB11          AF3    

# TIM4复用功能重映射

复用功能             管脚          重映射
TIM4_ETR            PA11          AF9
                    PB10          AF13
TIM4_CH1            PB6           AF3
                    PA7           AF9
TIM4_CH2            PB7           AF3    
                    PB8           AF10
TIM4_CH3            PA4           AF3
                    PA2           AF3
TIM4_CH4            PA5           AF6
                    PB9           AF3

# TIM5复用功能重映射        

复用功能             管脚          重映射
TIM5_CH1            PB12          AF13 
                    PA0           AF2
TIM5_CH2            PA1           AF8    
                    PB13          AF13
TIM5_CH3            PA2           AF7
TIM5_CH4            PA3           AF8

# TIM8复用功能重映射

复用功能             管脚          重映射
TIM8_ETR            PB7           AF13
                    PA0           AF8
TIM8_CH1            PA2           AF9
                    PB14          AF13
TIM8_CH2            PA3           AF10    
                    PB15          AF13
TIM8_CH3            PA4           AF9
                    PA6           AF9
                    PA5           AF2
                    PB4           AF10
                    PB8           AF10
TIM8_CH4            PA5           AF9
                    PB5           AF10
TIM8_BKIN           PA2           AF10 
                    PA6           AF7
                    PA9           AF10
                    PB5           AF13
TIM8_CH1N           PA7           AF7
                    PA15          AF11
                    PB15          AF8
TIM8_CH2N           PB0           AF8        
                    PB6           AF8
TIM8_CH3N           PB1           AF1
                    PB6           AF13

# LPTIM复用功能重映射

复用功能             管脚          重映射
LPTIM_ETR           PA10          AF12
                    PB6           AF9
LPTIM_IN1           PA5           AF12
                    PB5           AF3
LPTIM_IN2           PA9           AF12   
                    PB7           AF6
LPTIM_OUT           PA4           AF12
                    PB2           AF3

# CAN复用功能重映射

复用功能             管脚          重映射
CAN_RX              PA11          AF2
                    PA4           AF11
                    PB8           A6
                    PB6           AF11                 
CAN_TX              PA12          AF2
                    PA5           AF11
                    PB9           A6
                    PB7           AF11   

# USART1复用功能重映射

复用功能             管脚          重映射
USART1_CTS          PA11          AF5
USART1_RTS          PA12          AF5
USART1_TX           PA4           AF2
                    PA9           AF5
                    PB6           AF1
                    PB8           AF1
USART1_RX           PA10          AF5
                    PA5           AF5
                    PB7           AF1
USART1_CK           PA8           AF5

# USART2复用功能重映射

复用功能             管脚          重映射
USART2_CTS          PA0           AF5
                    PA15          AF7
USART2_RTS          PA1           AF5
                    PB3           AF5
USART2_TX           PA2           AF5
                    PA6           AF11
                    PB4           AF5
                    PD14          AF4
USART2_RX           PA3           AF5
                    PA7           AF11
                    PB5           AF7
                    PD15          AF4
USART2_CK           PA4           AF5
                    PA14          AF5

# UART3复用功能重映射

复用功能             管脚          重映射
UART3_TX            PB4           AF7
                    PB8           AF7
                    PB10          AF10
UART3_RX            PB5           AF8
                    PB9           AF7
                    PB11          AF10

# UART4复用功能重映射

复用功能             管脚          重映射
UART4_TX            PA0           AF11
                    PB0           AF7
                    PB14          AF7
                    PD13          AF6
UART4_RX            PB1           AF7
                    PB15          AF7
                    PD12          AF6

# IIC1复用功能重映射                   

复用功能             管脚          重映射
I2C1_SCL            PA4           AF8
                    PA15          AF8
                    PB6           AF2
                    PB8           AF5
                    PD13          AF7
I2C1_SDA            PA5           AF8
                    PA14          AF8
                    PB7           AF2
                    PB9           AF5
                    PD12          AF7
I2C1_SMBA           PB5           AF2

# IIC2复用功能重映射

复用功能             管脚          重映射
I2C2_SCL            PA3           AF6
                    PA9           AF7
                    PB10          AF7
                    PB13          AF6
                    PD15          AF6
I2C2_SDA            PA2           AF6
                    PA10          AF7
                    PA8           AF7
                    PB11          AF7
                    PB14          AF6
                    PD14          AF6
I2C2_SMBA           PB12          AF9
                    PA8           AF2
                    
# SPI1复用功能重映射

复用功能             管脚          重映射
SPI1_I2S1_NSS_WS    PA1           AF1   
                    PA4           AF1
                    PA8           AF6
                    PA15          AF1
                    PB6           AF5
SPI1_I2S1_SCK_CK    PA5           AF1
                    PA10          AF1
                    PB3           AF2
                    PB1           AF5
SPI1_I2S1_MISO_MCK  PA0           AF1
                    PA6           AF1
                    PB4           AF2
SPI1_I2S1_MOSI_SD   PA7           AF1
                    PB5           AF1

# SPI2复用功能重映射

复用功能             管脚          重映射
SPI2_I2S2_NSS_WS    PA4           AF3   
                    PA13          AF6
                    PA15          AF2
                    PB12          AF1
SPI2_I2S2_SCK_CK    PA10          AF1
                    PB6           AF6
                    PB13          AF1 
                    PD12          AF5
SPI2_I2S2_MISO_MCK  PA9           AF1
                    PA11          AF1
                    PA13          AF1
                    PB7           AF5
                    PB14          AF1
SPI2_I2S2_MOSI_SD   PA12          AF1
                    PA14          AF1
                    PB1           AF2                    
                    PB15          AF1

# COMP1复用功能重映射

复用功能             管脚          重映射
COMP1_OUT           PA0           AF9
                    PA11          AF8
                    PB6           AF10
                    PB8           AF8

# COMP2复用功能重映射

复用功能             管脚          重映射   
COMP2_OUT           PA2           AF8
                    PA6           AF8
                    PA7           AF8
                    PA12          AF8
                    PA14          AF9
                    PB9           AF8

# COMP3复用功能重映射

复用功能             管脚          重映射   
COMP3_OUT           PA6           AF10
                    PA8           AF10
                    PA10          AF10
                    PB10          AF11
                    PB4           AF11

# EVENTOUT复用功能重映射

复用功能             管脚          重映射
EVENTOUT            PA0~PA15      AF4     
                    PB0~PB15      AF4
                    PC13          AF4
                    PD12~PD13     AF4

# BEEPER复用功能重映射

复用功能             管脚          重映射
BEEPER_OUT_P        PA6           AF12
                    PB6           AF12
BEEPER_OUT_N        PA7           AF12
                    PB7           AF12

# JTAG/SWD复用功能重映射

复用功能             管脚          重映射
JTMS/SWDIO          PA13          AF0
JTCK/SWCLK          PA14          AF0
JTDI                PA15          AF0
JTDO                PB3           AF0
NJTRST              PB4           AF0

# TIMESTAMP复用功能重映射

复用功能             管脚          重映射
TIMESTAMP           PC13          AF9
                    PC14          AF9
                    PC15          AF9
                    
# RTC_REFIN复用功能重映射

复用功能             管脚          重映射
RTC_REFIN           PA10          AF9
                    PB15          AF9

# MCO复用功能重映射

复用功能             管脚          重映射
MCO                 PA8           AF9   
                    PA9           AF9   

## 系统的时钟设置

1.设置MCU外部晶振频率
#define HSE_VALUE (8000000)/#define HSI_VALUE (8000000)

2.选择板子的系统时钟来源和主频

#define SYSCLK_SRC SYSCLK_USE_HSE_PLL/#define SYSCLK_SRC SYSCLK_USE_HSI_PLL

## 获取系统时钟信息

时钟结构

```c
typedef struct
{
    uint32_t SysclkFreq;    /*  SYSCLK  */
    uint32_t HclkFreq;      /*  HCLK*/
    uint32_t Pclk1Freq;     /*  PCLK1 */
    uint32_t Pclk2Freq;     /*  PCLK2  */
    uint32_t AdcPllClkFreq; /*  ADCPLLCLK */
    uint32_t AdcHclkFreq;   /*  ADCHCLK */
} RCC_ClocksType;
```

获取时钟信息

```c
RCC_ClocksType RCC_ClocksStatus;
RCC_Clocks_Frequencies_Value_Get(&RCC_ClocksStatus);
```
# N32使用总结

## N32 中断使用总结

	中断配置
	1. 配置/初始化 NVIC_InitType 使用 NVIC_Initializes初始化中断管理控制器
		a. NVIC 的IRQ通道
		b. 优先级设置（包含抢占优先级和子优先级设置）
	2. 使能指定外设的中断
	3. 实现指定的中断服务函数
			1. 判定是否是等待的标志置1
			2. 清除标记

## N32 DMA使用总结

- N32单片机通道可以随意映射，不像STM32和GD32每个外设固定了dma通道

- dma使能以后，就不可以再次配置参数，配置后参数无效

	复位dma通道
	初始化dma  DMA_InitType 结构体
		- 外设地址 外设地址增长方式  外设数据宽度
		- 内存地址 内存地址增长方式  内存数据宽度
		- 数据传输大小
		- 优先级
		- 是否是内存到内存的数据传输
		
	
	映射通道请求
	指定外设DMA传输使能
	DMA通道使能
	
	如果需要开启中断：
		1. 配置/初始化 NVIC_InitType 使用 NVIC_Initializes初始化中断管理控制器
	        a. NVIC 的IRQ通道
	        b. 优先级设置（包含抢占优先级和子优先级设置）
		2. 使能指定外设的中断
		3. 实现指定的中断服务函数
			1. 判定是否是等待的标志置1
			2. 清除标记

## 

# GPIO的使用

1. 使能时钟
2. 配置gpio外设
   1. pin
   2. 操作模式
   3. 上下拉设置
   4. 速度
   5. 驱动强度
   6. 复用
3. 使用gpio

## gpio结构

```c
typedef struct
{
    uint32_t         Pin;            /* Specifies the GPIO pins to be configured. 哪一个pin*/

    uint32_t         GPIO_Mode;      /* Specifies the operating mode for the selected pins. 操作模式 */

    uint32_t         GPIO_Pull;      /* Specifies the Pull-up or Pull-Down activation for the selected pins. 选定引脚的上下拉激活方式*/

    uint32_t         GPIO_Slew_Rate; /* Specify the reverse speed for the selected pins. 驱动速度*/

    uint32_t         GPIO_Current;   /* Driving current of the select pins. 驱动强度设置*/

    uint32_t         GPIO_Alternate; /* Peripheral to be connected to the selected pins. 要连接到选定引脚的外围设备*/ 
}GPIO_InitType;
```

## 案例1：gpio输出实例

```c
void init_gpio_output()
{
    //初始化时钟
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //gpio初始化
    //定义gpio结构体
    GPIO_InitType GPIO_InitStructure;
    /* GPIO_Structure 初始化设置 */
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* pin*/
    GPIO_InitStructure.Pin          = pin;
    /* 工作模式 */
    GPIO_InitStructure.GPIO_Mode    = GPIO_MODE_OUT_PP;
    /* 速度*/
    GPIO_InitStructure.GPIO_Current = GPIO_DS_4MA;
    /*推挽-上拉-下拉  选择*/
    GPIO_InitStructure.GPIO_Pull = GPIO_PULL_UP;
    /* Initialize GPIO */
    GPIO_Peripheral_Initialize(GPIOx, &GPIO_InitStructure);
}
//pin置1
GPIO_Pins_Set(GPIOx, pin);
//pin置0
GPIO_Pins_Reset(GPIOx, pin);
//pin翻转
GPIO_Pin_Toggle(GPIOx, pin);;
//获取gpio电平
uint8_t GPIO_Input_Pin_Data_Get(GPIO_Module* GPIOx, uint16_t pin)
```
### 工作模式

> #define GPIO_MODE_INPUT     ((uint32_t)0x00000000U)  /*输入模式*/
> #define GPIO_MODE_OUT_PP    ((uint32_t)0x00000001U)  /*上拉 输出模式 */
> #define GPIO_MODE_OUT_OD    ((uint32_t)0x00000011U)  /* 开漏输出 */
> #define GPIO_MODE_AF_PP     ((uint32_t)0x00000002U)  /*复用上拉模式  */
> #define GPIO_MODE_AF_OD     ((uint32_t)0x00000012U)  /* 复用开漏模式 */
> #define GPIO_MODE_ANALOG    ((uint32_t)0x00000003U)  /* 模拟*/

### gpio的激活

>
>
>#define GPIO_NO_PULL         ((uint32_t)GPIO_PUPD0_0) /* 推挽 */
>#define GPIO_PULL_UP         ((uint32_t)GPIO_PUPD0_1) /* 上拉*/
>#define GPIO_PULL_DOWN       ((uint32_t)GPIO_PUPD0_2) /*下拉*/


### gpio速度

>
>
>#define GPIO_DS_2MA          ((uint32_t)GPIO_DS0_0)
>#define GPIO_DS_8MA          ((uint32_t)GPIO_DS0_1)
>#define GPIO_DS_4MA          ((uint32_t)GPIO_DS0_2)
>#define GPIO_DS_12MA         ((uint32_t)GPIO_DS0_3)


## gpio复用设置

这里复用为JTDI JTAG

1. GPIO_Alternate 设置
2. GPIO_Mode 设置

设置复用函数：


## 案例2：配置为sw模式

### 使用SW调试方式

```c
void disable_jatg_open_sw(void)
{
    GPIO_InitType GPIO_InitStructure;
	//1. 使能时钟
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA );
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOB );
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);


    GPIO_Structure_Initialize(&GPIO_InitStructure);

	//2.设置sw接口
    /* 配置 PA13 (JTMS)sw-dio 和 PA14 (JTDI) 作为 JTAG */
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//复用模式
    GPIO_InitStructure.GPIO_Pull      = GPIO_PULL_UP;//上拉
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SWDIO_JTMS;
    GPIO_InitStructure.Pin            = GPIO_PIN_13;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
    // PA14 (JTDI) 作为 JTAG sw-sclk */
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//复用模式
    GPIO_InitStructure.GPIO_Pull      = GPIO_PULL_DOWN;//下拉
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF0_SWCLK_JTCK;
    GPIO_InitStructure.Pin            = GPIO_PIN_14;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
    
	//3. 将PB3 PB4 PA15 作为gpio输出模式
    /* Configure PB3 (JTDO) 作为 gpio */
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_OUT_PP;
    GPIO_InitStructure.Pin            = GPIO_PIN_3;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    /* 配置 PB4 (JTRST) 作为 gpio */
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_OUT_PP;
    GPIO_InitStructure.Pin            = GPIO_PIN_4;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    /* Configure  PA15 (JTCK) 作为 gpio */
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_OUT_PP;
    GPIO_InitStructure.Pin            = GPIO_PIN_15;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

}
```

## 案例3：外部中断

### 使用步骤：

1. 配置时钟
2. 配置gpio
3. 配置中断源由那个gpio作为输入
4. 配置中断的触发参数
5. 配置中断管理单元
6. 编写中断服务函数

### 初始化配置

```c
void KeyInputExtiInit(GPIO_Module* GPIOx, uint16_t Pin)
{
    GPIO_InitType GPIO_InitStructure;
    EXTI_InitType EXTI_InitStructure;
    NVIC_InitType NVIC_InitStructure;

    /* 1.打开gpio时钟     打开复用时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
	RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);

    /*配置gpio为输入模式*/
    GPIO_InitStructure.Pin        = Pin;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_INPUT;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_Peripheral_Initialize(GPIOx, &GPIO_InitStructure);

    /*配置中断源*/
    GPIO_EXTI_Line_Set(EXTI_LINE_SOURCE5, AFIO_EXTI_PA5);

    /*配置中断触发参数*/
    EXTI_InitStructure.EXTI_Line    = EXTI_LINE5;//中断线
    EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;//中断或事件旋转
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; // 触发方式
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Peripheral_Initializes(&EXTI_InitStructure);
	
     /* 设置中断分组*/
    NVIC_Priority_Group_Set(NVIC_PER2_SUB2_PRIORITYGROUP);
    
    /*配置MVIC中断管理单元*/
    NVIC_InitStructure.NVIC_IRQChannel                   = EXTI9_5_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//抢占优先级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;//子优先级
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
}
```

### 中断服务函数

```c
void EXTI0_IRQHandler(void)
{
    //判断中断标志
    if (EXTI_Interrupt_Status_Get(KEY_INPUT_EXTI_LINE) != RESET)
    {
      //  Key_Status = ENABLE;
        /*  //清除中断标志 */
        EXTI_Flag_Status_Clear(KEY_INPUT_EXTI_LINE);
    }
}
```
# USART使用

## 实例1：使用串口实现printf



### 1.时钟初始化

```c
  void uart_enable_rcc()
  {
      /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
      //使能复用时钟
      RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO )
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_USART1);
  }

```

### 2.gpio初始化

```c
void uart_gpio_inti()
{
      GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);    

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);   

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;
    GPIO_Peripheral_Initialize(USARTx_GPIO, &GPIO_InitStructure); 
}
```
### 3.串口外设初始化

```c
void uart_init()
{
    USART_InitStructure.BaudRate            = 115200;
    USART_InitStructure.WordLength          = USART_WL_8B;
    USART_InitStructure.StopBits            = USART_STPB_1;
    USART_InitStructure.Parity              = USART_PE_NO;
    USART_InitStructure.HardwareFlowControl = USART_HFCTRL_NONE;
    USART_InitStructure.Mode                = USART_MODE_RX | USART_MODE_TX;

    /* 外设参数设置Configure USARTx */
    USART_Initializes(USART1, &USART_InitStructure);
    /* 使能Enable the USARTx */
    USART_Enable(USART1);
}

```

### 4.printf重定向

```c
int fputc(int ch, FILE* f)
{
    USART_Data_Send(USART1, (uint8_t)ch);
    //等待发送完成
    while (USART_Flag_Status_Get(USART1, USART_FLAG_TXDE) == RESET);
    return (ch);
}
```



## 示例2：使用空闲中断的方式接收数据

```c

#include "n32g430.h"
#include "bsp_uart.h"
#include "stdio.h"

static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_USART1);
}

static void uart_gpio_inti(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}

static void uart_init(void)
{
    USART_InitType  USART_InitStructure;

    USART_InitStructure.BaudRate            = 115200;
    USART_InitStructure.WordLength          = USART_WL_8B;
    USART_InitStructure.StopBits            = USART_STPB_1;
    USART_InitStructure.Parity              = USART_PE_NO;
    USART_InitStructure.HardwareFlowControl = USART_HFCTRL_NONE;
    USART_InitStructure.Mode                = USART_MODE_RX | USART_MODE_TX;

    /* 外设参数设置Configure USARTx */
    USART_Initializes(USART1, &USART_InitStructure);
    /* 使能Enable the USARTx */
    USART_Enable(USART1);
}

/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* Enable the USARTy Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel                   = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    USART_Interrput_Enable(USART1, USART_INT_RXDNE);
    USART_Interrput_Enable(USART1, USART_INT_IDLEF);


}

static uint8_t RxBuffer1[128], RxCounter1 = 0, idle = RESET;

void USART1_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(USART1, USART_INT_RXDNE) == SET)
    {
        /* 读取数据并清除标志 */
        RxBuffer1[RxCounter1++] = USART_Data_Receive(USART1);


    }
    else if (USART_Interrupt_Status_Get(USART1, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(USART1);
        idle = SET;

    }

}
/*
    获取串口是否空闲
*/
uint8_t get_uart_idle(void)
{
    volatile	uint8_t _idle = idle;
    idle = RESET;
    return _idle;
}/*
    获取串口数据
    data:一个数据缓冲区的指针
    返回：接收到的数据长度
*/
uint8_t get_receive_data(uint8_t **data)
{
    volatile	int len = RxCounter1;
    *data = RxBuffer1;
    RxCounter1 = 0;
    return len;
}
/*使用空闲中断来接收数据*/
void bsp_uart_base_init_it(void)
{
    uart_enable_rcc();
    uart_gpio_inti();
    NVIC_Configuration();
    uart_init();
}



```

## DMA

## 使用uart DMA recv --代码

```c

#include "n32g430.h"
#include "bsp_uart.h"
#include "stdio.h"
#include "string.h"
static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_USART1);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}

static void uart_init(void)
{
    USART_InitType  USART_InitStructure;

    USART_InitStructure.BaudRate            = 115200;
    USART_InitStructure.WordLength          = USART_WL_8B;
    USART_InitStructure.StopBits            = USART_STPB_1;
    USART_InitStructure.Parity              = USART_PE_NO;
    USART_InitStructure.HardwareFlowControl = USART_HFCTRL_NONE;
    USART_InitStructure.Mode                = USART_MODE_RX | USART_MODE_TX;

    /* 外设参数设置Configure USARTx */
    USART_Initializes(USART1, &USART_InitStructure);
    /* 使能Enable the USARTx */
    USART_Enable(USART1);
}

/*
    中断配置
    1. 配置/初始化 NVIC_InitType 使用 NVIC_Initializes初始化中断管理控制器
        a. NVIC 的IRQ通道
        b. 优先级设置（包含抢占优先级和子优先级设置）
    2. 使能指定外设的中断
    3. 实现指定的中断服务函数
            1. 判定是否是等待的标志置1
            2. 清除标记
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* Enable the USARTy Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel                   = USART1_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(USART1, USART_INT_IDLEF);


    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel4_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    
    DMA_Interrupts_Enable(DMA_CH4, DMA_INT_TXC);


}
#define BUFF_SIZE 128
static uint8_t RxBuffer1[BUFF_SIZE], RxCounter1 = 0, idle = RESET;

void USART1_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(USART1, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(USART1);
        idle = SET;
        RxCounter1 = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(DMA_CH4);

    }

}
/*
    复位dma通道
    初始化dma  DMA_InitType 结构体
        - 外设地址 外设地址增长方式  外设数据宽度
        - 内存地址 内存地址增长方式  内存数据宽度
        - 数据传输大小
        - 优先级
        - 是否是内存到内存的数据传输
        
    映射通道请求
    指定外设DMA传输使能
    DMA通道使能
    
    如果需要使能中断：
        1. 配置/初始化 NVIC_InitType 使用 NVIC_Initializes初始化中断管理控制器
            a. NVIC 的IRQ通道
            b. 优先级设置（包含抢占优先级和子优先级设置）
        2. 使能指定外设的中断
        3. 实现指定的中断服务函数
            1. 判定是否是等待的标志置1
            2. 清除标记
    
*/
static  void uart_dma_config()
{

    DMA_InitType DMA_InitStructure;

    /* USARTy_Tx_DMA_Channel (triggered by USARTy Tx event) Config */
    DMA_Reset(DMA_CH4);
    DMA_InitStructure.PeriphAddr     = (uint32_t)&(USART1->DAT);
    DMA_InitStructure.MemAddr        = (uint32_t)RxBuffer1;
    DMA_InitStructure.Direction      = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.BufSize        = BUFF_SIZE;
    DMA_InitStructure.PeriphInc      = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.MemoryInc      = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemDataSize    = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.CircularMode   = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Priority       = DMA_CH_PRIORITY_HIGH;
    DMA_InitStructure.Mem2Mem        = DMA_MEM2MEM_DISABLE;
    DMA_Initializes(DMA_CH4, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH4, DMA_REMAP_USART1_RX);

    USART_DMA_Transfer_Enable(USART1, USART_DMAREQ_RX );
    DMA_Channel_Enable(DMA_CH4);


}

void DMA_Channel4_IRQHandler(void)
{
    printf("DMA IT\r\r");

    if(SET == DMA_Interrupt_Status_Get(DMA, DMA_CH4_INT_TXC))
    {
        DMA_Interrupt_Status_Get(DMA, DMA_CH4_INT_TXC);


    }
}
uint8_t get_uart_dma_idle(void)
{
    volatile	uint8_t _idle = idle;
    idle = RESET;
    return _idle;
}
uint8_t get_receive_dma_data(uint8_t *data)
{
    volatile	int len = RxCounter1;
    RxCounter1 = 0;
        //拷贝数据
        memcpy(data,RxBuffer1,len);
    /*重新发起一轮数据传输*/
    DMA_Channel_Disable(DMA_CH4);
    DMA_Current_Data_Transfer_Number_Set(DMA_CH4, BUFF_SIZE);
    DMA_Channel_Enable(DMA_CH4);
    return len;
}
/*使用空闲中断来接收数据*/
void bsp_uart_base_init_it_dma(void)
{
    uart_enable_rcc();
    uart_gpio_init();
    NVIC_Configuration();
    uart_dma_config();
    uart_init();
}



```



## 使用UART+DMA发送数据--代码

```c

#include "n32g430.h"
#include "bsp_uart.h"
#include "stdio.h"
#include "string.h"
static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_USART1);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}

static void uart_init(void)
{
    USART_InitType  USART_InitStructure;

    USART_InitStructure.BaudRate            = 115200;
    USART_InitStructure.WordLength          = USART_WL_8B;
    USART_InitStructure.StopBits            = USART_STPB_1;
    USART_InitStructure.Parity              = USART_PE_NO;
    USART_InitStructure.HardwareFlowControl = USART_HFCTRL_NONE;
    USART_InitStructure.Mode                = USART_MODE_RX | USART_MODE_TX;

    /* 外设参数设置Configure USARTx */
    USART_Initializes(USART1, &USART_InitStructure);
    /* 使能Enable the USARTx */
    USART_Enable(USART1);
}

/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* Enable the USARTy Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel                   = USART1_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(USART1, USART_INT_IDLEF);


    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel4_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    
  
      


}
#define BUFF_SIZE 20
static uint8_t RxBuffer1[BUFF_SIZE],SxBuffer1[BUFF_SIZE], RxCounter1 = 0, idle = RESET;

void USART1_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(USART1, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(USART1);
        idle = SET;
        RxCounter1 = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(DMA_CH4);

    }

}

static  void uart_dma_config()
{

    DMA_InitType DMA_InitStructure;

    /* USARTy_Tx_DMA_Channel (triggered by USARTy Tx event) Config */
    DMA_Reset(DMA_CH4);
    DMA_InitStructure.PeriphAddr     = (uint32_t)&(USART1->DAT);
    DMA_InitStructure.MemAddr        = (uint32_t)RxBuffer1;
    DMA_InitStructure.Direction      = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.BufSize        = BUFF_SIZE;
    DMA_InitStructure.PeriphInc      = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.MemoryInc      = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemDataSize    = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.CircularMode   = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Priority       = DMA_CH_PRIORITY_HIGH;
    DMA_InitStructure.Mem2Mem        = DMA_MEM2MEM_DISABLE;
    DMA_Initializes(DMA_CH4, &DMA_InitStructure);
    
    DMA_Channel_Request_Remap(DMA_CH4, DMA_REMAP_USART1_RX);
        DMA_Interrupts_Enable(DMA_CH4, DMA_INT_TXC);
    USART_DMA_Transfer_Enable(USART1, USART_DMAREQ_RX );
    DMA_Channel_Enable(DMA_CH4);
        
        
        DMA_Reset(DMA_CH3);
    DMA_InitStructure.PeriphAddr     = (uint32_t)&(USART1->DAT);
    DMA_InitStructure.MemAddr        = (uint32_t)SxBuffer1;
    DMA_InitStructure.Direction      = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.BufSize        = 0;
    DMA_InitStructure.PeriphInc      = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.MemoryInc      = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemDataSize    = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.CircularMode   = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Priority       = DMA_CH_PRIORITY_HIGH;
    DMA_InitStructure.Mem2Mem        = DMA_MEM2MEM_DISABLE;
    DMA_Initializes(DMA_CH3, &DMA_InitStructure);
    
    DMA_Channel_Request_Remap(DMA_CH3, DMA_REMAP_USART1_TX);
        DMA_Interrupts_Enable(DMA_CH3, DMA_INT_TXC);
    USART_DMA_Transfer_Enable(USART1, USART_DMAREQ_TX );
   
        
        DMA_Flag_Status_Clear(DMA,DMA_CH4_TXCF);
        DMA_Interrupt_Status_Clear(DMA,DMA_CH4_INT_TXC);


}

void DMA_Channel4_IRQHandler(void)
{

    if(SET == DMA_Interrupt_Status_Get(DMA, DMA_CH4_INT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, DMA_CH4_INT_TXC);
                idle =SET;
                RxCounter1 = BUFF_SIZE;
    }
        
        
}
/*
使用dma方式发送数据至串口
*/
void send_data_dma(uint8_t *data,const int len)
{
     memcpy(SxBuffer1,data,len);
    /*重新发起一轮数据传输*/
    DMA_Channel_Disable(DMA_CH3);
    DMA_Current_Data_Transfer_Number_Set(DMA_CH3, len);
    DMA_Channel_Enable(DMA_CH3);
}
uint8_t get_uart_dma_idle(void)
{
    
    volatile	uint8_t _idle = idle;
    idle = RESET;
    return _idle;
}
uint8_t get_receive_dma_data(uint8_t *data)
{
    volatile	int len = RxCounter1;
    RxCounter1 = 0;
        //拷贝数据
        memcpy(data,RxBuffer1,len);
    /*重新发起一轮数据传输*/
    DMA_Channel_Disable(DMA_CH4);
    DMA_Current_Data_Transfer_Number_Set(DMA_CH4, BUFF_SIZE);
    DMA_Channel_Enable(DMA_CH4);
    return len;
}
/*使用空闲中断来接收数据*/
void bsp_uart_base_init_it_dma(void)
{
    uart_enable_rcc();
    uart_gpio_init();
    NVIC_Configuration();
    uart_dma_config();
    uart_init();
}



```

## 串口配置封装函数 dma发送接收+空闲 +dma版的printf

### common.h

```c
#ifndef _BSP_UART_H_
#define _BSP_UART_H_
#include "stdint.h"
#include "n32g430.h"

#define BUFF_SIZE 128

typedef void (*f_init)(void);
typedef struct 
{
    USART_Module *uart;						//串口号
    uint32_t bate;
    DMA_ChannelType *dma_ch_recv; //dma接收数据通道
    DMA_ChannelType *dma_ch_send;//dma发送数据通道
    //dma中断标志
    uint32_t rx_IT_TXC; //dma 接收数据完成
    uint32_t tx_IT_TXC;//dma 发送数据完成
    
    uint32_t dma_ch_remap_rx;
    uint32_t dma_ch_remap_tx;
    
    uint8_t rx_buff[BUFF_SIZE];//接收数据缓冲区
    uint8_t tx_buff[BUFF_SIZE];	//发送数据缓冲区
    uint8_t idle;								//串口空闲标志
    uint8_t 	send_busy;
    uint16_t rx_len;						//已经接收到的数据标志
    //初始化函数
    f_init rcc_init;
    f_init gpio_init;
    f_init nvic_init;
    
}uart_handle_t;
/*
    串口1
*/
uart_handle_t * uart1_init_handle(void);
uart_handle_t * get_uart1_hanlde(void);

/*
    串口2
*/
uart_handle_t * uart2_init_handle(void);
uart_handle_t *get_uart2_handle(void);


/*
    串口3
*/
uart_handle_t * uart3_init_handle(void);
uart_handle_t *get_uart3_handle(void);



/*
    串口4
*/
uart_handle_t * uart4_init_handle(void);
uart_handle_t *get_uart4_handle(void);


/*公共函数*/
void receive_new_fram_data(uart_handle_t *uart_hd,const uint32_t  len);
void send_data_dma(uart_handle_t *uart_hd,const int len);
/*串口+dma +ild 初始化函数*/
void bsp_uart_init(uart_handle_t *uart_hd);
#endif 

```



### common.c

```c
#include "bsp_uart_dma.h"
#include "string.h"
#include "stdio.h"
/*

    串口的基本初始化
*/
void uart_init(uart_handle_t *uart_hd)
{
        if(!uart_hd)printf("uart handle is not init\r\n");
    USART_InitType  USART_InitStructure;
    USART_InitStructure.BaudRate            = uart_hd->bate;
    USART_InitStructure.WordLength          = USART_WL_8B;
    USART_InitStructure.StopBits            = USART_STPB_1;
    USART_InitStructure.Parity              = USART_PE_NO;
    USART_InitStructure.HardwareFlowControl = USART_HFCTRL_NONE;
    USART_InitStructure.Mode                = USART_MODE_RX | USART_MODE_TX;

    /* 外设参数设置Configure USARTx */
    USART_Initializes(uart_hd->uart, &USART_InitStructure);
    /* 使能Enable the USARTx */
    USART_Enable(uart_hd->uart);
}
/*
    串口DMA传输函数
*/
void uart_dma_config(uart_handle_t *uart)
{
        if(!uart)printf("uart handle is not init\r\n");
    DMA_InitType DMA_InitStructure;

    /* 使用DMA接收数据配置 */
    DMA_Reset(uart->dma_ch_recv);
    DMA_InitStructure.PeriphAddr     = (uint32_t)&(uart->uart->DAT);			//串口数据寄存器
    DMA_InitStructure.MemAddr        = (uint32_t)uart->rx_buff; 					//接收数据缓冲区
    DMA_InitStructure.Direction      = DMA_DIR_PERIPH_SRC;						//数据传输方向
    DMA_InitStructure.BufSize        = BUFF_SIZE;											//缓冲区大小
    DMA_InitStructure.PeriphInc      = DMA_PERIPH_INC_MODE_DISABLE;		//外设地址不增加
    DMA_InitStructure.MemoryInc      = DMA_MEM_INC_MODE_ENABLE;				//内存地址自动增加
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;		//外设数据宽度
    DMA_InitStructure.MemDataSize    = DMA_MEM_DATA_WIDTH_BYTE;				//内存数据宽度
    DMA_InitStructure.CircularMode   = DMA_CIRCULAR_MODE_DISABLE;			//循环传输失能
    DMA_InitStructure.Priority       = DMA_CH_PRIORITY_HIGH;					//dma优先级
    DMA_InitStructure.Mem2Mem        = DMA_MEM2MEM_DISABLE;						//不是内存到内存的传输方式
        //初始化DMA
    DMA_Initializes(uart->dma_ch_recv, &DMA_InitStructure);
        //DMA 通道映射
    DMA_Channel_Request_Remap(uart->dma_ch_recv, uart->dma_ch_remap_rx);
        //DMA 传输完成中断使能
        DMA_Interrupts_Enable(uart->dma_ch_recv, DMA_INT_TXC);
        //DMA使能
    DMA_Channel_Enable(uart->dma_ch_recv);
        
        //串口DMA 接收使能
    USART_DMA_Transfer_Enable(uart->uart, USART_DMAREQ_RX );
        
        
         /* 使用DMA发送数据配置 */
        DMA_Reset(uart->dma_ch_send);
    DMA_InitStructure.PeriphAddr     = (uint32_t)&(uart->uart->DAT);		//串口数据寄存器
    DMA_InitStructure.MemAddr        = (uint32_t)uart->tx_buff;					//发送数据缓冲区
    DMA_InitStructure.Direction      = DMA_DIR_PERIPH_DST;					//数据传输方向
    DMA_InitStructure.BufSize        = 0;														//缓冲区大小
    DMA_InitStructure.PeriphInc      = DMA_PERIPH_INC_MODE_DISABLE; //外设地址不增加
    DMA_InitStructure.MemoryInc      = DMA_MEM_INC_MODE_ENABLE;			//内存地址自动增加
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;	//外设数据宽度
    DMA_InitStructure.MemDataSize    = DMA_MEM_DATA_WIDTH_BYTE;			//内存数据宽度
    DMA_InitStructure.CircularMode   = DMA_CIRCULAR_MODE_DISABLE;		//循环传输失能
    DMA_InitStructure.Priority       = DMA_CH_PRIORITY_HIGH;				//dma优先级
    DMA_InitStructure.Mem2Mem        = DMA_MEM2MEM_DISABLE;					//不是内存到内存的传输方式
        //初始化DMA
    DMA_Initializes(uart->dma_ch_send, &DMA_InitStructure);
        //DMA 通道映射
    DMA_Channel_Request_Remap(uart->dma_ch_send, uart->dma_ch_remap_tx);
        //DMA 传输完成中断使能
        DMA_Interrupts_Enable(uart->dma_ch_send, DMA_INT_TXC);
        
        //串口DMA 接收使能
    USART_DMA_Transfer_Enable(uart->uart, USART_DMAREQ_TX );
   
}

/*
使用dma方式发送数据至串口
*/
void send_data_dma(uart_handle_t *uart_hd,const int len)
{
        if(!uart_hd)printf("uart handle is not init\r\n");
    /*重新发起一轮数据传输*/
    DMA_Channel_Disable(uart_hd->dma_ch_send);
    DMA_Current_Data_Transfer_Number_Set(uart_hd->dma_ch_send, len);
    DMA_Channel_Enable(uart_hd->dma_ch_send);
        uart_hd->send_busy=1;
}

void receive_new_fram_data(uart_handle_t *uart_hd,const uint32_t  len)
{
        if(!uart_hd)printf("uart handle is not init\r\n");
    /*重新发起一轮数据传输*/
    DMA_Channel_Disable(uart_hd->dma_ch_recv);
    DMA_Current_Data_Transfer_Number_Set(uart_hd->dma_ch_recv, len);
    DMA_Channel_Enable(uart_hd->dma_ch_recv);

}

/*串口+dma +ild 初始化函数*/
void bsp_uart_init(uart_handle_t *uart_hd)
{
    if(!uart_hd)printf("uart handle is not init\r\n");
    uart_hd->rcc_init();
    uart_hd->gpio_init();
    uart_hd->nvic_init();
    uart_init(uart_hd);
    uart_dma_config(uart_hd);
}

```

### DMA版的printf

```c
int fputc(int ch, FILE* f)
{

    static uint8_t cache[128];
    static uint8_t len=0;
    cache[len++]=ch;
    
    uart_handle_t *handle = get_uart1_hanlde();
    if((len>100|| cache[len-1]=='\n')&& !handle->send_busy)
    {
        
        memcpy(handle->tx_buff,cache,len);
        send_data_dma(handle,len);
        len=0;
        memset(cache,0,len);
    }
   return (ch);
}

```

### bsp_uart1_config.c

```c

#include "n32g430.h"
#include "bsp_uart_dma.h"
#include "stdio.h"
#include "string.h"

static uart_handle_t uart;

static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_USART1);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_9;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}


/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* 使能串口中断 */
    NVIC_InitStructure.NVIC_IRQChannel                   = USART1_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(USART1, USART_INT_IDLEF);

        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel3_IRQn; 
    NVIC_Initializes(&NVIC_InitStructure);
    
    //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel4_IRQn;
    NVIC_Initializes(&NVIC_InitStructure);

}

void USART1_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(uart.uart, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(uart.uart);
        uart.idle = SET;
        uart.rx_len = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(uart.dma_ch_recv);

    }

}

void DMA_Channel3_IRQHandler(void)
{

if(SET == DMA_Interrupt_Status_Get(DMA, uart.rx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.rx_IT_TXC);
                uart.idle =SET;
                uart.rx_len = BUFF_SIZE;
    }
        
        
}
void DMA_Channel4_IRQHandler(void)
{

    
            if(SET == DMA_Interrupt_Status_Get(DMA, uart.tx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.tx_IT_TXC);
                uart.send_busy=0;
    }
        
}


uart_handle_t * uart1_init_handle(void)
{
    uart_handle_t *uart_hd = &uart;
    
    uart_hd->uart = USART1;
    uart_hd->bate = 115200;
    uart_hd->dma_ch_recv = DMA_CH3;
    uart_hd->dma_ch_send = DMA_CH4;
    uart_hd->dma_ch_remap_rx =  DMA_REMAP_USART1_RX;
    uart_hd->dma_ch_remap_tx =  DMA_REMAP_USART1_TX;
    uart_hd->rx_IT_TXC = DMA_CH3_INT_TXC;
    uart_hd->tx_IT_TXC = DMA_CH4_INT_TXC;

    uart.idle=0;
    uart.rx_len =0;
    
    uart.rcc_init = uart_enable_rcc;
    uart.gpio_init = uart_gpio_init;
    uart.nvic_init = NVIC_Configuration;
    
    

    return uart_hd;
}

uart_handle_t * get_uart1_hanlde(void)
{
    return &uart;
}

```

### bsp_uart2_config.c

```c

#include "n32g430.h"
#include "bsp_uart_dma.h"
#include "stdio.h"
#include "string.h"

static uart_handle_t uart;

static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB1_Peripheral_Clock_Enable(RCC_APB1_PERIPH_USART2);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_2;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART2;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_3;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF5_USART2;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}

/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* 使能串口中断 */
    NVIC_InitStructure.NVIC_IRQChannel                   = USART2_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(USART2, USART_INT_IDLEF);

        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel5_IRQn; 
    NVIC_Initializes(&NVIC_InitStructure);
    
    //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel6_IRQn;
    NVIC_Initializes(&NVIC_InitStructure);

}


void USART2_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(uart.uart, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(uart.uart);
        uart.idle = SET;
        uart.rx_len = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(uart.dma_ch_recv);

    }

}

void DMA_Channel5_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.rx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.rx_IT_TXC);
                uart.idle =SET;
                uart.rx_len = BUFF_SIZE;
    }
        
}
void DMA_Channel6_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.tx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.tx_IT_TXC);
                
    }
        
}


uart_handle_t * uart2_init_handle(void)
{
    uart_handle_t *uart_hd = &uart;
    uart_hd->uart = USART2;
    uart_hd->bate = 115200;
    uart_hd->dma_ch_recv = DMA_CH5;
    uart_hd->dma_ch_send = DMA_CH6;
    uart_hd->dma_ch_remap_rx =  DMA_REMAP_USART2_RX;
    uart_hd->dma_ch_remap_tx =  DMA_REMAP_USART2_TX;
    uart_hd->rx_IT_TXC = DMA_CH5_INT_TXC;
    uart_hd->tx_IT_TXC = DMA_CH6_INT_TXC;

    uart.idle=0;
    uart.rx_len =0;
    
    uart.rcc_init = uart_enable_rcc;
    uart.gpio_init = uart_gpio_init;
    uart.nvic_init = NVIC_Configuration;
    return uart_hd;
}

uart_handle_t *get_uart2_handle(void)
{
    return &uart;
}


```

### bsp_uart3_config.c

```c

#include "n32g430.h"
#include "bsp_uart_dma.h"
#include "stdio.h"
#include "string.h"

static uart_handle_t uart;

static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOB);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_UART3);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF10_UART3;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_11;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF10_UART3;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* 使能串口中断 */
    NVIC_InitStructure.NVIC_IRQChannel                   = UART3_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(UART3, USART_INT_IDLEF);

        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel7_IRQn; 
    NVIC_Initializes(&NVIC_InitStructure);
    
        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel8_IRQn;
    NVIC_Initializes(&NVIC_InitStructure);

}

void UART3_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(uart.uart, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(uart.uart);
        uart.idle = SET;
        uart.rx_len = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(uart.dma_ch_recv);

    }

}

void DMA_Channel7_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.rx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.rx_IT_TXC);
                uart.idle =SET;
                uart.rx_len = BUFF_SIZE;
    }
        
}
void DMA_Channel8_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.tx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.tx_IT_TXC);
                
    }
        
}


uart_handle_t * uart3_init_handle(void)
{
    uart_handle_t *uart_hd = &uart;
    uart_hd->uart = UART3;
    uart_hd->bate = 115200;
    uart_hd->dma_ch_recv = DMA_CH7;
    uart_hd->dma_ch_send = DMA_CH8;
    uart_hd->dma_ch_remap_rx =  DMA_REMAP_UART3_RX;
    uart_hd->dma_ch_remap_tx =  DMA_REMAP_UART3_TX;
    uart_hd->rx_IT_TXC = DMA_CH7_INT_TXC;
    uart_hd->tx_IT_TXC = DMA_CH8_INT_TXC;

    uart.idle=0;
    uart.rx_len =0;
    
    uart.rcc_init = uart_enable_rcc;
    uart.gpio_init = uart_gpio_init;
    uart.nvic_init = NVIC_Configuration;
    return uart_hd;
}

uart_handle_t *get_uart3_handle(void)
{
    return &uart;
}


```

### bsp_uart4_config.c

```c

#include "n32g430.h"
#include "bsp_uart_dma.h"
#include "stdio.h"
#include "string.h"

static uart_handle_t uart;

static void uart_enable_rcc(void)
{
    /* 使能gpio时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOB);
    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /* 使能uart外设时钟 */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_UART4);
    /* 使能DMA时钟 */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}

static void uart_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    /* 配置gpio*/
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* Configure USARTx Tx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_0;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//这里设置为复用模式
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF7_UART4;//这里复用为第5中方式
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    /* Configure USARTx Rx as alternate function push-pull */
    GPIO_InitStructure.Pin            = GPIO_PIN_1;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF7_UART4;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

/*
    中断配置
*/

static void NVIC_Configuration(void)
{
    NVIC_InitType NVIC_InitStructure;

    /* 使能串口中断 */
    NVIC_InitStructure.NVIC_IRQChannel                   = UART4_IRQn;
      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    USART_Interrput_Enable(UART4, USART_INT_IDLEF);

        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel1_IRQn; 
    NVIC_Initializes(&NVIC_InitStructure);
    
        //使能DMA中断
    NVIC_InitStructure.NVIC_IRQChannel                   = DMA_Channel2_IRQn;
    NVIC_Initializes(&NVIC_InitStructure);

}

void UART4_IRQHandler(void)
{
    if (USART_Interrupt_Status_Get(uart.uart, USART_INT_IDLEF) == SET)
    {
        /* 清除IDLE标志*/
        USART_Data_Receive(uart.uart);
        uart.idle = SET;
        uart.rx_len = BUFF_SIZE - DMA_Current_Data_Transfer_Number_Get(uart.dma_ch_recv);
    }
}

void DMA_Channel1_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.rx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.rx_IT_TXC);
                uart.idle =SET;
                uart.rx_len = BUFF_SIZE;
    }
        
}
void DMA_Channel2_IRQHandler(void)
{

    
        if(SET == DMA_Interrupt_Status_Get(DMA, uart.tx_IT_TXC))
    {
        DMA_Interrupt_Status_Clear(DMA, uart.tx_IT_TXC);
                
    }
        
}


uart_handle_t * uart4_init_handle(void)
{
    uart_handle_t *uart_hd = &uart;
    uart_hd->uart = UART4;
    uart_hd->bate = 115200;
    uart_hd->dma_ch_recv = DMA_CH1;
    uart_hd->dma_ch_send = DMA_CH2;
    uart_hd->dma_ch_remap_rx =  DMA_REMAP_UART4_RX;
    uart_hd->dma_ch_remap_tx =  DMA_REMAP_UART4_TX;
    uart_hd->rx_IT_TXC = DMA_CH1_INT_TXC;
    uart_hd->tx_IT_TXC = DMA_CH2_INT_TXC;

    uart.idle=0;
    uart.rx_len =0;
    
    uart.rcc_init = uart_enable_rcc;
    uart.gpio_init = uart_gpio_init;
    uart.nvic_init = NVIC_Configuration;
    return uart_hd;
}

uart_handle_t *get_uart4_handle(void)
{
    return &uart;
}


```

# systick 定时器

- Systick定时器就是系统滴答定时器，一个**24 位的倒计数定时器**，计到0 时，将从RELOAD 寄存器中自动重装载定时初值
- 时钟源是系统是系统时钟的8分频

## 寄存器

## 代码

SYSTICK 配置函数

```c
/*
    SYSTICK 配置函数
*/
static uint32_t DBG_SysTick_Config(uint32_t ticks)
{ 
    if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* 如果定时器的定时tick >0xffffff 则返回异常 */
                                                               
    SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
    NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* 设置中断分组的优先级 */
    SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
                     SysTick_CTRL_ENABLE_Msk;                    /* 使能中断和使能内部时钟源*/
    SysTick->CTRL  &= ~SysTick_CTRL_TICKINT_Msk;									//使能定时器
    return (0);                                                  /* Function successful */
}
```

延时函数：

```c

/**
 *\*\name    SysTick_Delay_Us.
 *\*\fun     us 的延时函数.
 *\*\param   us :any number
 *\*\return  none
**/
void SysTick_Delay_Us( __IO uint32_t us)
{
    uint32_t i;	
    RCC_ClocksType RCC_Clocks;
    
    RCC_Clocks_Frequencies_Value_Get(&RCC_Clocks);
    DBG_SysTick_Config(RCC_Clocks.SysclkFreq / 1000000);
    
    for(i=0;i<us;i++)
    {
        /* When the counter value decreases to 0, bit 16 of the CRTL register will be set to 1 */
        /* When set to 1, reading this bit will clear it to 0 */
        while( !((SysTick->CTRL)&(1<<16)) );
    }
    /* Turn off the SysTick timer */
    SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
}

/**
 *\*\name    SysTick_Delay_Us.
 *\*\fun     ms 的延时函数
 *\*\param   ms :any number
 *\*\return  none
**/
void SysTick_Delay_Ms( __IO uint32_t ms)
{
    uint32_t i;	
    RCC_ClocksType RCC_Clocks;
    
    RCC_Clocks_Frequencies_Value_Get(&RCC_Clocks);
    DBG_SysTick_Config(RCC_Clocks.SysclkFreq / 1000);
    
    for(i=0;i<ms;i++)
    {
        /* When the counter value decreases to 0, bit 16 of the CRTL register will be set to 1 */
        /* When set to 1, reading this bit will clear it to 0 */
        while( !((SysTick->CTRL)&(1<<16)) );
    }
    /* Turn off the SysTick timer */
    SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
}
```

中断处理

```c
void SysTick_Handler(void)
{
    
    
}
```

# TIM 

定时器的时钟频率由硬件自动设置，分以下两种情况：
如果 APB 预分频为 1，则定时器时钟频率与定时器所在的 APB 频率相同。
如果 APB 预分频不为 1，则定时器时钟频率是定时器所在的 APB 频率的 2 倍。

## 案例-基本定时器的使用

1. 使能时钟

2. 使能外设
3. 使能中断
4. 使能定时器
5. 实现中断服务函数

定时器配置

```c
#include "bsp_time_base.h"
#include "bsp_gpio.h"
static void  rcc_init_time(void)
{
          //时钟初始化
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_TIM1);   
}


static void bsp_time_it_init(void)
{
    //定时器中断配置
    NVIC_InitType NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
        //使能定时器中断
    TIM_Interrupt_Enable(TIM1, TIM_INT_UPDATE);
}
void bsp_time_base_init(void)
{
    //时钟初始化
    rcc_init_time();
    //中断初始化
    bsp_time_it_init();
    TIM_TimeBaseInitType TIM_TimeBaseStructure;
    //外设初始化 每秒中断一次
    TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Period    = 100-1;
    TIM_TimeBaseStructure.Prescaler = 128-1;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;
    TIM_Base_Initialize(TIM1, &TIM_TimeBaseStructure);   

    //启用定时器重载
    TIM_Base_Reload_Mode_Set(TIM1, TIM_PSC_RELOAD_MODE_IMMEDIATE);
    //使能定时器
    TIM_On(TIM1);
}
```

2.实现定时器中断

```c
void TIM1_UP_IRQHandler(void)
{
    //判断定时器的中断标志
    if (TIM_Interrupt_Status_Get(TIM1, TIM_INT_UPDATE) != RESET)
    {
        //清除中断标志
        TIM_Interrupt_Status_Clear(TIM1, TIM_INT_UPDATE);
        //gpio 输出
        GPIO_Pin_Toggle(GPIOB, GPIO_PIN_3);
                
    }
}
```

## 案例-pwm信号输出

## 刹车

使用刹车功能时，设置相应的控制位时会**修改输出使能信号和无效电平**

**TIM1 最多 9 个通道，TIM8 最多 6 个通道**

刹车信号来源

- 刹车输入引脚
- 时钟失效事件，由时 RCC 中的时钟安全系统（CSS）生成。
- PVD 事件。
-  内核 Hardfault 事件。
- 比较器的输出信号（在比较器模块中配置，高电平刹车）。
- 软件设置 TIMx_EVTGEN.BGN。

### 引脚模式和复用设置

### 案例-代码

本次使用 PA8 PA9 PA10 作为pwm 3路输出，PB13 PB 14 PB15 为pwm互补输出，配置模式和复用功能如上图

### 使用步骤

1. 使能时钟（定时器，pwm gpio ，刹车gpio）

2. 使能外设（定时器和gpio， 刹车gpio）

3. 定时器的基本参数初始化

4. 配置pwm参数

5. 配置刹车参数

6. 使能定时器

7. 使能pwm输出-设置刹车主输出

   

```c
#include "bsp_time_pwm.h"
#include "bsp_gpio.h"
static void  rcc_init_time(void)
{
    //时钟初始化
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_TIM1); 
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);  
}

static void pwm_gpio_init(void)
{
        GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Current = GPIO_DS_4MA;

    /* TIM1 CHx 输出 */
    GPIO_InitStructure.Pin        = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);


    /* TIM1 CHxN 输出 */
    GPIO_InitStructure.Pin        = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
static void break_config(void)
{
    //刹车gpio配置
        GPIO_InitType GPIO_InitStructure;
        GPIO_Structure_Initialize(&GPIO_InitStructure);
    
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_INPUT;
    GPIO_InitStructure.GPIO_Current = GPIO_DS_4MA;
    GPIO_InitStructure.Pin       = GPIO_PIN_12;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF6_TIM1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
    
        //刹车配置
        TIM_BDTRInitType TIM_BDTRInitStructure;
        TIM_Break_And_Dead_Time_Struct_Initialize(&TIM_BDTRInitStructure);
    
    TIM_BDTRInitStructure.OssrState       = TIM_OSSR_STATE_ENABLE;
    TIM_BDTRInitStructure.OssiState       = TIM_OSSI_STATE_ENABLE;
    TIM_BDTRInitStructure.LockLevel       = TIM_LOCK_LEVEL_1;
    TIM_BDTRInitStructure.DeadTime        = 11;//死区时间
    TIM_BDTRInitStructure.Break           = TIM_BREAK_IN_ENABLE;//外部刹车使能
    TIM_BDTRInitStructure.BreakPolarity   = TIM_BREAK_POLARITY_HIGH;
    TIM_BDTRInitStructure.AutomaticOutput = TIM_AUTO_OUTPUT_ENABLE;
    TIM_BDTRInitStructure.IomBreakEn      = true;

    TIM_Break_And_Dead_Time_Set(TIM1, &TIM_BDTRInitStructure);
}

static void time_pwm_config(void)
{
     //pwm通道配置
    OCInitType TIM_OCInitStructure;
    TIM_OCInitStructure.OcMode       = TIM_OCMODE_PWM2;//使用pwm2模式
    TIM_OCInitStructure.OutputState  = TIM_OUTPUT_STATE_ENABLE;//pwm 输出使能--内部通过这个直接控制了pwm输出，不需要再次调用 void TIM_Capture_Compare_Ch_Enable(TIM_Module* TIMx, uint16_t channel);
    TIM_OCInitStructure.OutputNState = TIM_OUTPUT_NSTATE_ENABLE;//互补输出使能
    TIM_OCInitStructure.Pulse        = 25;//占空比设置
    TIM_OCInitStructure.OcPolarity   = TIM_OC_POLARITY_LOW;//有效电平
    TIM_OCInitStructure.OcNPolarity  = TIM_OCN_POLARITY_LOW;//有效空闲电平
    TIM_OCInitStructure.OcIdleState  = TIM_OC_IDLE_STATE_SET;////空闲电平
    TIM_OCInitStructure.OcNIdleState = TIM_OCN_IDLE_STATE_RESET;//互补空闲电平
    TIM_Output_Channel1_Initialize(TIM1, &TIM_OCInitStructure);
    
    TIM_OCInitStructure.Pulse = 50;
    TIM_Output_Channel2_Initialize(TIM1, &TIM_OCInitStructure);
    
    TIM_OCInitStructure.Pulse = 75;
    TIM_Output_Channel3_Initialize(TIM1, &TIM_OCInitStructure);
}
static void bsp_time_it_init(void)
{
    //定时器中断配置
    NVIC_InitType NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
        //使能定时器中断
    TIM_Interrupt_Enable(TIM1, TIM_INT_UPDATE);
}


static void bsp_time_base_init(void)
{
    
    
    
    TIM_TimeBaseInitType TIM_TimeBaseStructure;
    //外设初始化 每秒中断一次
    TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Period    = 100-1;
    TIM_TimeBaseStructure.Prescaler = 128-1;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;
    TIM_Base_Initialize(TIM1, &TIM_TimeBaseStructure);   

    //启用定时器重载
    //TIM_Base_Reload_Mode_Set(TIM1, TIM_PSC_RELOAD_MODE_IMMEDIATE);

    
    
    
}
void bsp_pwm_init(void)
{
    //时钟初始化
    rcc_init_time();
    pwm_gpio_init();
    //中断初始化
    bsp_time_it_init();
    break_config();
    time_pwm_config();
    bsp_time_base_init();
     //使能定时器
    TIM_On(TIM1);
    //使能pwm输出--就是刹车寄存区的控制，普通定时器不需要
    TIM_PWM_Output_Enable(TIM1);
}

void TIM1_UP_IRQHandler(void)
{
    //判断定时器的中断标志
    if (TIM_Interrupt_Status_Get(TIM1, TIM_INT_UPDATE) != RESET)
    {
        //清除中断标志
        TIM_Interrupt_Status_Clear(TIM1, TIM_INT_UPDATE);
                //gpio 输出
                GPIO_Pin_Toggle(GPIOB, GPIO_PIN_3);
                
    }
}

```

#### 实现pwm输出控制

>可以实现pwm输出控制
>
>TIM_Capture_Compare_Ch_Enable(TIM_Module* TIMx, uint16_t channel);
>
>void TIM_Capture_Compare_Ch_Disable(TIM_Module* TIMx, uint16_t channel);



#### pwm 脉宽设置

>void 3TIM_Compare1_Set(TIM_Module* TIMx, uint16_t compare1);
>void TIM_Compare2_Set(TIM_Module* TIMx, uint16_t compare2);
>void TIM_Compare3_Set(TIM_Module* TIMx, uint16_t compare3);
>void TIM_Compare4_Set(TIM_Module* TIMx, uint16_t compare4);
>void TIM_Compare5_Set(TIM_Module* TIMx, uint16_t compare5);
>void TIM_Compare6_Set(TIM_Module* TIMx, uint16_t compare6);
>void TIM_Compare7_Set(TIM_Module* TIMx, uint16_t compare7);
>void TIM_Compare8_Set(TIM_Module* TIMx, uint16_t compare8);
>void TIM_Compare9_Set(TIM_Module* TIMx, uint16_t compare9);
>
>





## 定时器的触发与同步 主从



作为主定时器可选的触发信号


>        对于所有的定时器:
>
>        TIM_TRGO_SRC_RESET           复位信号，上升沿重新初始化计数器
>
>        TIM_TRGO_SRC_ENABLE          定时器的使能信号
>
>        TIM_TRGO_SRC_UPDATE          更新信号.
>
>        除开 TIM6的定时器:
>
>        TIM_TRGO_SRC_OC1             捕获或比较成功
>
>        TIM_TRGO_SRC_OC1REF          比较 - OC1REF 信号.
>
>        TIM_TRGO_SRC_OC2REF           比较 - OC2REF 信号.
>
>        TIM_TRGO_SRC_OC3REF          比较 - OC3REF 信号.
>
>        TIM_TRGO_SRC_OC4REF          比较 - OC4REF 信号.
>        仅仅用于 TIM1：
>
>        TIM_TRGO_SRC_OC4_7_8_9REF    比较-如果计数器为中央对齐模式：OC4REF/OC7REF/OC8REF/OC9REF的相应边沿信号作为触发输出（TRGO）.




从定时器可选模式：

>TIM_SLAVE_MODE_RESET   复位模式.
>TIM_SLAVE_MODE_GATED    门控模式. 高电平计数，低电平停止计数
> TIM_SLAVE_MODE_TRIG     触发模式.  -启动定时器
>TIM_SLAVE_MODE_EXT1     上升沿计数



从定时器可选的触发信号

>
>
>#define TIM_TRIG_SEL_IN_TR0  (TIM_REG16_BIT_ZERO)
>#define TIM_TRIG_SEL_IN_TR1  (TIM_SMCTRL_TSEL_0)
>#define TIM_TRIG_SEL_IN_TR2  (TIM_SMCTRL_TSEL_1)
>#define TIM_TRIG_SEL_IN_TR3  (TIM_SMCTRL_TSEL_1 | TIM_SMCTRL_TSEL_0)
>#define TIM_TRIG_SEL_TI1F_ED (TIM_SMCTRL_TSEL_2)
>#define TIM_TRIG_SEL_TI1FP1  (TIM_SMCTRL_TSEL_2 | TIM_SMCTRL_TSEL_0)
>#define TIM_TRIG_SEL_TI2FP2  (TIM_SMCTRL_TSEL_2 | TIM_SMCTRL_TSEL_1)
>#define TIM_TRIG_SEL_ETRF    (TIM_SMCTRL_TSEL_2 | TIM_SMCTRL_TSEL_1 | TIM_SMCTRL_TSEL_0)



### 案例-定时器主从触发

```c

    /***********************时钟配置*******************************/
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_TIM1);
    RCC_APB1_Peripheral_Clock_Enable(RCC_APB1_PERIPH_TIM3);
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
    /***********************时钟配置*******************************/
    
    /************************ TIM1 CH1 CH2 CH3  gpio 输出 ************************/
    GPIO_InitStructure.Pin        = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
        /************************ TIM1 CH1 CH2 CH3  gpio 输出 ************************/

     /************************ TIM3 CH1 CH2 CH3  gpio 输出 ************************/
        GPIO_InitStructure.Pin        = GPIO_PIN_6|GPIO_PIN_7;
        GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
        GPIO_InitStructure.GPIO_Current = GPIO_DS_4MA;
        GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM3;
        GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

        GPIO_InitStructure.Pin        = GPIO_PIN_0;
        GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM3;
        GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
 /************************ TIM3 CH1 CH2 CH3  gpio 输出 ************************/

    
    定时器TIM1
        
        
        /***********************tim base配置*******************************/
    //TIM1
    TIM_TimeBaseInitType TIM_TimeBaseStructure;
    TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Period    = 100-1;
    TIM_TimeBaseStructure.Prescaler = 128-1;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;
    TIM_Base_Initialize(TIM1, &TIM_TimeBaseStructure); 

    //TIM3
     TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Period    = 100;
    TIM_TimeBaseStructure.Prescaler = 64-1;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;

    TIM_Base_Initialize(TIM3, &TIM_TimeBaseStructure);   
     /***********************tim base配置*******************************/
       
    /************************ TIM1 CH1 CH2 CH3  pwm 输出配置 ************************/
    TIM_Output_Channel_Struct_Initialize(&TIM_OCInitStructure);
    TIM_OCInitStructure.OcMode       = TIM_OCMODE_PWM2;
    TIM_OCInitStructure.OutputState  = TIM_OUTPUT_STATE_ENABLE;
    TIM_OCInitStructure.OutputNState = TIM_OUTPUT_NSTATE_DISABLE;//互补输出禁止
    TIM_OCInitStructure.Pulse        = 127;
    TIM_OCInitStructure.OcPolarity   = TIM_OC_POLARITY_LOW;
    TIM_OCInitStructure.OcNPolarity  = TIM_OCN_POLARITY_LOW;
    TIM_OCInitStructure.OcIdleState  = TIM_OC_IDLE_STATE_SET;
    TIM_OCInitStructure.OcNIdleState = TIM_OC_IDLE_STATE_RESET;
    TIM_Output_Channel1_Initialize(TIM1, &TIM_OCInitStructure);
    /************************ TIM1 CH1 CH2 CH3  pwm 输出配置 ************************/

    /************************ TIM3 CH1 CH2 CH3  pwm 输出配置 ************************/
    TIM_Output_Channel_Struct_Initialize(&TIM_OCInitStructure);
    TIM_OCInitStructure.OcMode      = TIM_OCMODE_PWM1;
    TIM_OCInitStructure.OutputState = TIM_OUTPUT_STATE_ENABLE;
    TIM_OCInitStructure.Pulse       = 1;
    TIM_Output_Channel1_Initialize(TIM3, &TIM_OCInitStructure);
    
    TIM_OCInitStructure.Pulse       = 2;
    TIM_Output_Channel2_Initialize(TIM3, &TIM_OCInitStructure);

    TIM_OCInitStructure.Pulse       = 3;
    TIM_Output_Channel3_Initialize(TIM3, &TIM_OCInitStructure);
/************************ TIM3 CH1 CH2 CH3  pwm 输出配置 ************************/

/* TIM1工作在主模式 */
    TIM_Master_Slave_Mode_Set(TIM1, TIM_MASTER_SLAVE_MODE_ENABLE);
    /* 设置更新信号为输出触发信号 */
    TIM_Output_Trigger_Select(TIM1, TIM_TRGO_SRC_UPDATE);


    /*  TIM3 的从模式 工作在门控模式*/
    TIM_Slave_Mode_Select(TIM3, TIM_SLAVE_MODE_GATED);
    //选择 TRO 为触发信号
    TIM_Trigger_Source_Select(TIM3, TIM_TRIG_SEL_IN_TR0);


 /* TIM1 PWM 输出 */
    TIM_PWM_Output_Enable(TIM1);
    /* TIM 使能 */
    TIM_On(TIM1);
    TIM_On(TIM3);

```
## 定时器输入捕获功能

```c
#include "bsp_time_pwm.h"
#include "bsp_gpio.h"
#include "stdio.h"
static void  bsp_tim_capture_rcc_init(void)
{
    //时钟初始化
    RCC_APB1_Peripheral_Clock_Enable(RCC_APB1_PERIPH_TIM3);
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
}

static void bsp_tim_capture_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;
    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* TIM3 CH2 PA7 配置*/
    GPIO_InitStructure.Pin            = GPIO_PIN_7;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_INPUT;
    GPIO_InitStructure.GPIO_Current   = GPIO_DS_12MA;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM3;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
}

static void bsp_tim_capture_config(void)
{

    //配置TIM3的输入捕获
        
    
    TIM_ICInitType TIM_ICInitStructure;
    TIM_ICInitStructure.Channel     = TIM_CH_2;
    TIM_ICInitStructure.IcPolarity  = TIM_IC_POLARITY_BOTHEDGE;//上升沿触发
    TIM_ICInitStructure.IcSelection = TIM_IC_SELECTION_DIRECTTI;
    TIM_ICInitStructure.IcPrescaler = TIM_IC_PSC_DIV1;
    TIM_ICInitStructure.IcFilter    = 0x20;
    TIM_PWM_Input_Channel_Config(TIM3, &TIM_ICInitStructure);
    //选择触发源是 TI2FP2
    TIM_Trigger_Source_Select(TIM3, TIM_TRIG_SEL_TI2FP2);
    //工作在复位模式
    TIM_Slave_Mode_Select(TIM3, TIM_SLAVE_MODE_RESET);
    //主从模式打开
    TIM_Master_Slave_Mode_Set(TIM3, TIM_MASTER_SLAVE_MODE_ENABLE);
}


static void bsp_tim_capture_it_init(void)
{
    NVIC_InitType NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    /* 输入捕获2中断打开 */
    TIM_Interrupt_Enable(TIM3, TIM_INT_CC2);
}


static void bsp_tim_capture_base_init(void)
{

    TIM_TimeBaseInitType TIM_TimeBaseStructure;
    //外设初始化 每秒中断一次
    TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Prescaler = 64 - 1;
    TIM_TimeBaseStructure.Period    = 0xffff;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;
    TIM_Base_Initialize(TIM3, &TIM_TimeBaseStructure);
    //启用定时器重载
    //TIM_Base_Reload_Mode_Set(TIM1, TIM_PSC_RELOAD_MODE_IMMEDIATE);
}


void bsp_tim_capture_init(void)
{
    
    bsp_tim_capture_rcc_init();//时钟初始化
    bsp_tim_capture_gpio_init();//gpio初始化
    bsp_tim_capture_base_init();//定时器捕初始化
    bsp_tim_capture_config();//输入捕获初始化
    bsp_tim_capture_it_init();//中断初始化
    
    
    //使能定时器
    TIM_On(TIM3);
   
}
static uint32_t IC2Value=0;
static uint32_t DutyCycle=0;
static uint32_t Frequency=0;
const uint32_t GPTIMClockFrequency=1000000;
void TIM3_IRQHandler(void)
{
    if(SET == TIM_Interrupt_Status_Get(TIM3,TIM_INT_CC2))
    {
    /* 清除输入捕获2的中断标志 */
    TIM_Interrupt_Status_Clear(TIM3, TIM_INT_CC2);

    /* 获取计数值 */
    IC2Value = TIM_Compare_Capture2_Get(TIM3);
            
    if (IC2Value != 0)
    {
        /* Duty cycle computation */
        DutyCycle = (TIM_Compare_Capture1_Get(TIM3) * 100) / IC2Value;

        /* Frequency computation */
        Frequency = GPTIMClockFrequency / IC2Value;
            
                printf("%d %d \r\n",DutyCycle,Frequency);
    }
    else
    {
        DutyCycle = 0;
        Frequency = 0;
    }
    }
}

```

中断服务函数

```c
void TIM3_IRQHandler(void)
{
    /* 清除输入捕获2的中断标志 */
    TIM_Interrupt_Status_Clear(TIM3, TIM_INT_CC2);

    /* 获取计数值 */
    IC2Value = TIM_Compare_Capture2_Get(TIM3);

    if (IC2Value != 0)
    {
        /* Duty cycle computation */
        DutyCycle = (TIM_Compare_Capture1_Get(TIM3) * 100) / IC2Value;

        /* Frequency computation */
        Frequency = GPTIMClockFrequency / IC2Value;
    }
    else
    {
        DutyCycle = 0;
        Frequency = 0;
    }
}
```



## hall 输入

1. 时钟初始化{ gpio,time,复用}
2. 三个引脚初始化
3. 3个引脚的异或输入
4. 配置输入捕获1通道为输入为**TRC**
5. 复位模式 -输入信号上升沿复位定时器
6. 设置通道4为pwm输出模式，根据通道一定时器cnt的时间适当设置设置ccr4寄存器的值可以实现实现通道4的pwm占空比，也就是延时输出；
8. 开启通道1的更新中断-在更新中断内部可以获取cnt得到换向时间，也就是电机速度

#### TIM2获取HALL信号

```c

#include "bsp_time_pwm.h"
#include "bsp_gpio.h"
#include "stdio.h"
//时钟初始化
static void  bsp_tim_hall_rcc_init(void)
{
    //时钟初始化
    RCC_APB1_Peripheral_Clock_Enable(RCC_APB1_PERIPH_TIM2);
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA);
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);

    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOB);
}
//外设gpio初始化
static void bsp_tim_hall_gpio_init(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);

    /* TIM2 CH0 CH1 CH2  输入捕获gpio配置*/
    GPIO_InitStructure.Pin            = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_INPUT;
    GPIO_InitStructure.GPIO_Current   = GPIO_DS_12MA;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM2;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);
    //通道4的pwm输出初始化
    GPIO_InitStructure.Pin            = GPIO_PIN_11;
    GPIO_InitStructure.GPIO_Mode      = GPIO_MODE_AF_PP;//复用上拉
    GPIO_InitStructure.GPIO_Current   = GPIO_DS_12MA;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF3_TIM2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
/*
    将CH0 CH1 CH2  作为HALL信号的输入配置
*/
static void bsp_tim_hall_config(void)
{

    //使能异或输入
    TIM_Hall_Sensor_Enable(TIM2);

    TIM_ICInitType TIM_ICInitStructure;
    //配置TIM3的输入捕获
    TIM_ICInitStructure.Channel     = TIM_CH_1;
    TIM_ICInitStructure.IcPolarity  = TIM_IC_POLARITY_RISING;//上下升沿触发
    TIM_ICInitStructure.IcSelection = TIM_IC_SELECTION_TRC; //选择TRC触发模式
    TIM_ICInitStructure.IcPrescaler = TIM_IC_PSC_DIV1;
    TIM_ICInitStructure.IcFilter    = 0x0;
    TIM_PWM_Input_Channel_Config(TIM2, &TIM_ICInitStructure);

    //选择触发源是 TI1F_ED --也就是异或后的信号
    TIM_Trigger_Source_Select(TIM2, TIM_TRIG_SEL_TI1F_ED);
    //工作在复位模式
    TIM_Slave_Mode_Select(TIM2, TIM_SLAVE_MODE_RESET);
    //主从模式打开
    TIM_Master_Slave_Mode_Set(TIM2, TIM_MASTER_SLAVE_MODE_ENABLE);

}

/*
    在hall信号输入之后延时指定的时间输出com时间，同时通道4输出异或后的pwm信号
*/
static void bsp_tim_hall_pwm_config(void)
{
    //pwm通道配置
    OCInitType TIM_OCInitStructure;
    TIM_OCInitStructure.OcMode       = TIM_OCMODE_PWM2;//使用pwm2模式
    TIM_OCInitStructure.OutputState  = TIM_OUTPUT_STATE_ENABLE;//pwm 输出使能--内部通过这个直接控制了pwm输出，不需要再次调用 void TIM_Capture_Compare_Ch_Enable(TIM_Module* TIMx, uint16_t channel);
    TIM_OCInitStructure.OutputNState = TIM_OUTPUT_NSTATE_DISABLE;//互补输出使能
    TIM_OCInitStructure.Pulse        = 25;//占空比设置
    TIM_OCInitStructure.OcPolarity   = TIM_OC_POLARITY_LOW;//有效电平
    TIM_OCInitStructure.OcNPolarity  = TIM_OCN_POLARITY_LOW;//有效空闲电平
    TIM_OCInitStructure.OcIdleState  = TIM_OC_IDLE_STATE_SET;////空闲电平
    TIM_OCInitStructure.OcNIdleState = TIM_OCN_IDLE_STATE_RESET;//互补空闲电平
    TIM_Output_Channel4_Initialize(TIM2, &TIM_OCInitStructure);

    //使能通道4的pwm比较输出使能
    TIM_Interrupt_Enable(TIM2, TIM_INT_CC4);
    //使用OC4REF 作为TRGO的输出参考信号
    TIM_Output_Trigger_Select(TIM2, TIM_TRGO_SRC_OC4REF);
}

static void bsp_tim_hall_it_init(void)
{
    //定时器2的中断分组使能
    NVIC_InitType NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    /* 使能TIME 的跟新中断 */
    //TIM_Interrupt_Enable(TIM2, TIM_INT_UPDATE); //这里的更新信号，也是定时器复位信号也是输入触发信号
    //使能通道1的输入捕获信号，即hall异或之后的信号
    TIM_Interrupt_Enable(TIM2, TIM_INT_CC1);
}


static void bsp_tim_hall_base_init(void)
{

    TIM_TimeBaseInitType TIM_TimeBaseStructure;
    //外设初始化 每秒中断一次
    TIM_Base_Struct_Initialize(&TIM_TimeBaseStructure);
    TIM_TimeBaseStructure.Prescaler = 64 - 1;
    TIM_TimeBaseStructure.Period    = 0xffff;
    TIM_TimeBaseStructure.ClkDiv    = 0;
    TIM_TimeBaseStructure.CntMode   = TIM_CNT_MODE_UP;
    TIM_Base_Initialize(TIM2, &TIM_TimeBaseStructure);
    //启用定时器重载
    //TIM_Base_Reload_Mode_Set(TIM1, TIM_PSC_RELOAD_MODE_IMMEDIATE);
}


void bsp_tim_hall_init(void)
{

    bsp_tim_hall_rcc_init();//时钟初始化
    bsp_tim_hall_gpio_init();//gpio初始化
    bsp_tim_hall_base_init();//定时器捕初始化
    bsp_tim_hall_config();//输入捕获初始化
    bsp_tim_hall_it_init();//中断初始化
    bsp_tim_hall_pwm_config();

    //使能定时器
    TIM_On(TIM2);

}

void TIM2_IRQHandler(void)
{
    if (SET == TIM_Interrupt_Status_Get(TIM2, TIM_INT_UPDATE))
    {
        /* 清除更新中断标志 */
        TIM_Interrupt_Status_Clear(TIM2, TIM_INT_UPDATE);

        printf("%d %d \r\n", 1, TIM_Compare_Capture1_Get(TIM2));
    }
    if (SET == TIM_Interrupt_Status_Get(TIM2, TIM_INT_CC1))
    {
        /* 清除更新中断标志 */
        TIM_Interrupt_Status_Clear(TIM2, TIM_INT_CC1);

        printf("%d %d \r\n", 2, TIM_Compare_Capture1_Get(TIM2));
    }
    else if (SET == TIM_Interrupt_Status_Get(TIM2, TIM_INT_CC4))
    {
        /* 清除更新中断标志 */
        TIM_Interrupt_Status_Clear(TIM2, TIM_INT_CC4);
        //给定时器TIM1产生一个COM事件--延迟给出COM信号
        TIM_Event_Generate(TIM1, TIM_EVT_SRC_COM);
        printf("%d %d \r\n", 3, TIM_Compare_Capture1_Get(TIM2));
    }
}

```

#### 使用gpio 模拟hall传感器信号输出

```c
/*使用gpio 模拟hall传感器信号输出*/
    if (cnt++  == 150)
    {
        GPIO_Pin_Toggle(GPIOB, GPIO_PIN_2);
        
        cnt=0;
    }
    else if (cnt   == 100)
    {
        GPIO_Pin_Toggle(GPIOB, GPIO_PIN_4);
        
    }
    else if (cnt   == 50)
    {
        GPIO_Pin_Toggle(GPIOA, GPIO_PIN_15);    
    }
```

# SPI

## 基本知识

### spi主模式下使用硬件NSS（3个条件缺一不可）：

1. 设置硬件NSS模式
2. 设置NSS电平为低电平
3. 使能NSS输出

### spi主模式下使用软件NSS（3个条件缺一不可）：

1. 设置软件NSS模式

2. 使能NSS输出

   > SPI_SS_Output_Enable(SPI1);//NSS 使能

### SPI接线方式(MISO 和MOSI反着接)

SPI1->SLCK=PB3   <-->  SPI2->SLCK=PB13

SPI1->MISO=PB4   <-->  SPI2->MISO=PB15

SPI1->MOSI= PB5   <-->  SPI3->MOSI= PB14

## 配置spi为单工通讯方式的接线说明

### SPI结构体

```c
typedef struct
{
    uint16_t DataDirection; /* 数据发送方向 */
    uint16_t SpiMode;       /* 主，从模式 */              
    uint16_t DataLen;       /* 数据长度 */
    uint16_t CLKPOL;        /* 时钟初始电平 */                 
    uint16_t CLKPHA;        /* 第几个边沿采集 */
    uint16_t NSS;           /*硬件NSS，软件NSS */
    uint16_t FirstBit;      /* MSB ， LSB  */
    uint16_t CRCPoly;       /* crc检验 */
} SPI_InitType;
```

## 引脚映射

## 中断方式接收发送数据代码

SPI 软件NSS 必须设置NSS电平为高

>SPI_NSS_Config(SPI1, SPI_NSS_SOFT);
>SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 4
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0X0102, 0X0304, 0X0506, 0X0708,};
static uint16_t  SPI_Slave_Buffer_Rx[BufferSize];
static uint32_t TxIdx = 0, RxIdx = 0;

/*
#define SPI_MASTER_MOSI_PIN       GPIO_PIN_7
#define SPI_MASTER_MISO_PIN       GPIO_PIN_6
#define SPI_MASTER_CLK_PIN        GPIO_PIN_5
#define SPI_MASTER_NSS_PIN        GPIO_PIN_4

#define SPI_SLAVE_MOSI_PIN        GPIO_PIN_15
#define SPI_SLAVE_MISO_PIN        GPIO_PIN_14
#define SPI_SLAVE_CLK_PIN         GPIO_PIN_13
#define SPI_SLAVE_NSS_PIN         GPIO_PIN_12
*/

static void bsp_spi_it_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);
}
static void bsp_spi_it_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_7;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOA, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

static void bsp_spi_it_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = SPI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    //使能外设spi的中断
    SPI_I2S_Interrupts_Enable(SPI1, SPI_I2S_INT_TE);
    SPI_I2S_Interrupts_Enable(SPI2, SPI_I2S_INT_RNE);


}
static void bsp_spi_it_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;//发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;//主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_16BITS;//数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW; //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;//第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_HARD;//硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;//时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);
    SPI_NSS_Config(SPI1, SPI_NSS_SOFT);
    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    //  SPI_SS_Output_Enable(SPI1);//NSS 使能
    //SPI_CRC_Disable(SPI1);

    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
    SPI_NSS_Config(SPI2, SPI_NSS_SOFT);
    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}

void SPI1_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI1, SPI_I2S_INT_FLAG_TE) != RESET)
    {
        /* Send SPI_MASTER data */
        SPI_I2S_Data_Transmit(SPI1, SPI_Master_Buffer_Tx[TxIdx++]);
        if (TxIdx == BufferSize)
        {
            /* Disable SPI_MATER TXE interrupt */
            SPI_I2S_Interrupts_Disable(SPI1, SPI_I2S_INT_TE);

        }
    }
}

/**

**/
void SPI2_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI2, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        /* Store SPI_SLAVE received data */
        //printf("%02x ",SPI_I2S_Data_Get(SPI2));
        SPI_Slave_Buffer_Rx[RxIdx++] = SPI_I2S_Data_Get(SPI2);
    }
}
/*spi 中断模式接收发送数据测试*/
void bsp_spi_it_init(void)
{
    //外设时钟使能
    bsp_spi_it_rcc_cinfig();
    //外设gpio设置
    bsp_spi_it_gpio_config();
    //中断配置
    bsp_spi_it_nvic_config();
    //spi外设配置
    bsp_spi_it_config();
    /* 使能spi外设 */
    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_it_test(void)
{
    //轮训方式发送接收数据
//  while(1)
//  {
//
//      while(RESET ==SPI_I2S_Flag_Status_Get(SPI1,SPI_I2S_FLAG_TE));
//      SPI_I2S_Data_Transmit(SPI1, SPI_Master_Buffer_Tx[TxIdx++%4]);
    
//      GPIO_Pin_Toggle(GPIOB, GPIO_PIN_2);
    
//      while(RESET ==SPI_I2S_Flag_Status_Get(SPI2,SPI_I2S_FLAG_RNE));
//      printf("%02x ",SPI_I2S_Data_Get(SPI2));
//
//
//}
    while (RxIdx < 4)
    {
        SysTick_Delay_Ms(1);
    }


    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }
    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}



```

## SPI1 使用中断发送数据 SPI2 使用代码接收数据

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32
uint16_t RxIdx=0,TxIdx=0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                             0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                             0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                             0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40};
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                            0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                            0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                            0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90};
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];

static void bsp_spi_it_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);
    
        /*dma 时钟设置*/
      RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}
static void bsp_spi_it_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

static void bsp_spi_it_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = SPI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    //使能外设spi的中断
    SPI_I2S_Interrupts_Enable(SPI1, SPI_I2S_INT_TE);
    //SPI_I2S_Interrupts_Enable(SPI2, SPI_I2S_INT_RNE);


}
static void bsp_spi_it_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;//发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;//主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_16BITS;//数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW; //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;//第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_HARD;//硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;//时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);
    //SPI_NSS_Config(SPI1, SPI_NSS_SOFT);
    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
      SPI_SS_Output_Enable(SPI1);//NSS 使能


    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
    SPI_NSS_Config(SPI2, SPI_NSS_SOFT);
         SPI_Set_Nss_Level(SPI1, SPI_NSS_LOW);
    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}

void SPI1_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI1, SPI_I2S_INT_FLAG_TE) != RESET)
    {
        /* Send SPI_MASTER data */
        SPI_I2S_Data_Transmit(SPI1, SPI_Master_Buffer_Tx[TxIdx++]);
        if (TxIdx == BufferSize)
        {
            /* Disable SPI_MATER TXE interrupt */
            SPI_I2S_Interrupts_Disable(SPI1, SPI_I2S_INT_TE);

        }
    }
}

/**

**/
void SPI2_IRQHandler(void)
{
//    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI2, SPI_I2S_INT_FLAG_RNE) == SET)
//    {
//        /* Store SPI_SLAVE received data */
//        //printf("%02x ",SPI_I2S_Data_Get(SPI2));
//        SPI_Slave_Buffer_Rx[RxIdx++] = SPI_I2S_Data_Get(SPI2);
//    }
}
static void bps_spi_dma_config(void)
{
 DMA_InitType DMA_InitStructure;
  
    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);
        
        DMA_Channel_Enable(DMA_CH1);
        SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
    }

/*spi 中断模式接收发送数据测试*/
void bsp_spi_it_init(void)
{
    //外设时钟使能
    bsp_spi_it_rcc_cinfig();
    //外设gpio设置
    bsp_spi_it_gpio_config();
    //中断配置
    bsp_spi_it_nvic_config();
    //spi外设配置
    bsp_spi_it_config();
    /* 使能spi外设 */
     bps_spi_dma_config();
    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_it_test(void)
{
//  while(1)
//  {
//
//      while(RESET ==SPI_I2S_Flag_Status_Get(SPI1,SPI_I2S_FLAG_TE));
//      printf("%02x ",SPI_Slave_Buffer_Rx[TxIdx%4]);
//      SPI_I2S_Data_Transmit(SPI1, SPI_Master_Buffer_Tx[TxIdx++%4]);
//      GPIO_Pin_Toggle(GPIOB, GPIO_PIN_2);
//      //while(RESET ==SPI_I2S_Flag_Status_Get(SPI2,SPI_I2S_FLAG_RNE));
//
//
//}
    
    while(DMA_Flag_Status_Get(DMA, DMA_CH1_TXCF) == RESET);
//    while (RxIdx < 32)
//    {
//        SysTick_Delay_Ms(1);
//    }


    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }
    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}
```
## SPI1 DMA发送数据，SPI2 中断接收数据

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32
uint16_t RxIdx = 0, TxIdx = 0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                                    0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                                    0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                                    0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40
                                                   };
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                                   0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                                   0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                                   0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90
                                                  };
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];

static void bsp_spi_it_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);

    /*dma 时钟设置*/
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}
static void bsp_spi_it_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

static void bsp_spi_it_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = SPI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    //使能外设spi的中断
    //SPI_I2S_Interrupts_Enable(SPI1, SPI_I2S_INT_TE);
    SPI_I2S_Interrupts_Enable(SPI2, SPI_I2S_INT_RNE);


}
static void bsp_spi_it_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_TX;//发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;//主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_16BITS;//数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW; //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;//第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_HARD;//硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;//时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);
    //SPI_NSS_Config(SPI1, SPI_NSS_SOFT);
    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI1);//NSS 使能


    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
    SPI_NSS_Config(SPI2, SPI_NSS_SOFT);
    SPI_Set_Nss_Level(SPI1, SPI_NSS_LOW);
    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}

void SPI1_IRQHandler(void)
{
//    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI1, SPI_I2S_INT_FLAG_TE) != RESET)
//    {
//        /* Send SPI_MASTER data */
//        SPI_I2S_Data_Transmit(SPI1, SPI_Master_Buffer_Tx[TxIdx++]);
//        if (TxIdx == BufferSize)
//        {
//            /* Disable SPI_MATER TXE interrupt */
//            SPI_I2S_Interrupts_Disable(SPI1, SPI_I2S_INT_TE);

//        }
//    }
}

/**

**/
void SPI2_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI2, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        SPI_Slave_Buffer_Rx[RxIdx++] = SPI_I2S_Data_Get(SPI2);
    }
}
/*
    功能：配置SPI2为dma接收
*/
static void bps_spi_dma_config(void)
{
    DMA_InitType DMA_InitStructure;

    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);

    DMA_Channel_Enable(DMA_CH1);
    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
}


/*
功能：配置SPI1为dma发送
    
    1. 配置dma
    2. 通道映射
    3. spi 外设的dma发送使能
*/
static void bps_spi_dma_config2(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH2);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH2, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH2, DMA_REMAP_SPI1_TX);

    DMA_Channel_Enable(DMA_CH2);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_TX);
}


/*spi 中断模式接收发送数据测试*/
void bsp_spi_it_init(void)
{
    //外设时钟使能
    bsp_spi_it_rcc_cinfig();
    //外设gpio设置
    bsp_spi_it_gpio_config();
    //中断配置
    bsp_spi_it_nvic_config();
    //spi外设配置
    bsp_spi_it_config();
    /* 使能spi外设 */
    bps_spi_dma_config2();
    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_it_test(void)
{
    while(DMA_Flag_Status_Get(DMA, DMA_CH2_TXCF) == RESET);

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }

    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}

```

## spi1使用dma发送数据，中断收数据，spi2使用中断收数据，轮训发送数据

### 接线方式是 miso->miso  mosi->mosi  -------SPI工作在3线全双工模式下

SPI1->SLCK=PB3   <-->  SPI2->SLCK=PB13

SPI1->MISO=PB4   <--> SPI3->MOSI= PB14

SPI1->MOSI= PB5   <-->   SPI2->MISO=PB15

spi1使用dma发送数据，中断收数据，spi2使用中断收数据，轮训发送数据

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32
static uint16_t RxIdx = 0, TxIdx = 0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                                    0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                                    0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                                    0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40
                                                   };
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                                   0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                                   0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                                   0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90
                                                  };
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];
/*时钟使能
    1.gpio时钟
    2.spi我外设时钟
  3.dma时钟																									
*/
static void bsp_spi_dma_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);

    /*dma 时钟设置*/
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}
/*
    spi gpio配置

*/
static void bsp_spi_dma_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
/*
    spi 中断相关配置
*/
static void bsp_spi_dma_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = SPI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    //使能外设spi的中断
    SPI_I2S_Interrupts_Enable(SPI1, SPI_I2S_INT_RNE);
    SPI_I2S_Interrupts_Enable(SPI2, SPI_I2S_INT_RNE);

}
static uint16_t recnt=0,txcnt=0;
void SPI1_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI1, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        SPI_Master_Buffer_Rx[recnt++] = SPI_I2S_Data_Get(SPI1);
    }
}

void SPI2_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI2, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        SPI_Slave_Buffer_Rx[RxIdx++] = SPI_I2S_Data_Get(SPI2);
                
    }
}
/*
    spi外设相关配置
*/
static void bsp_spi_dma_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_DOUBLELINE_FULLDUPLEX;		//发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;					//主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;			//数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW; 					//时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;		//第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_SOFT;							//硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;			//时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);

    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI1);//NSS 使能


    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    //SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
        SPI_Set_Nss_Level(SPI2, SPI_NSS_LOW);
 
    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}

/*
    功能：配置SPI2为dma接收
*/
static void bps_spi_dma_dma_config(void)
{
    DMA_InitType DMA_InitStructure;

    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);

    DMA_Channel_Enable(DMA_CH1);
    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
}


/*
功能：配置SPI1为dma发送
    
    1. 配置dma
    2. 通道映射
    3. spi 外设的dma发送使能
*/
static void bps_spi_dma_dma_config2(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH2);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH2, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH2, DMA_REMAP_SPI1_TX);

    DMA_Channel_Enable(DMA_CH2);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_TX);
}
/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config3(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH3);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH3, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH3, DMA_REMAP_SPI2_TX);

    DMA_Channel_Enable(DMA_CH3);

    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_TX);
}


/*spi 中断模式接收发送数据测试*/
void bsp_spi_dma_init(void)
{
    //外设时钟使能
    bsp_spi_dma_rcc_cinfig();
    //外设gpio设置
    bsp_spi_dma_gpio_config();
    //中断配置
    bsp_spi_dma_nvic_config();
    //spi外设配置
    bsp_spi_dma_config();
    /* 使能spi外设 */
    bps_spi_dma_dma_config2();
        //bps_spi_dma_dma_config3();
    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_dma_test(void)
{
    
        uint8_t *send= (uint8_t *)SPI_Slave_Buffer_Tx;
        while(txcnt<32){
        while (SPI_I2S_Flag_Status_Get(SPI2, SPI_I2S_FLAG_TE) == RESET);
            SPI_I2S_Data_Transmit(SPI2,send[txcnt++]);
        }
    while(DMA_Flag_Status_Get(DMA, DMA_CH2_TXCF) == RESET);
        //while(DMA_Flag_Status_Get(DMA, DMA_CH3_TXCF) == RESET);

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }

    printf("\r\n");
        
        for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Master_Buffer_Rx[i]);
    }

    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}
```

## 使用spi1使用dma发送数据，中断收数据，spi2使用中断收数据，dma发送数据---SPI工作在3线全双工模式下

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32
static uint16_t RxIdx = 0, TxIdx = 0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                                    0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                                    0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                                    0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40
                                                   };
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                                   0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                                   0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                                   0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90
                                                  };
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];
/*时钟使能
    1.gpio时钟
    2.spi我外设时钟
  3.dma时钟																									
*/
static void bsp_spi_dma_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);

    /*dma 时钟设置*/
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);
}
/*
    spi gpio配置

*/
static void bsp_spi_dma_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
/*
    spi 中断相关配置
*/
static void bsp_spi_dma_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = SPI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);
    //使能外设spi的中断
    SPI_I2S_Interrupts_Enable(SPI1, SPI_I2S_INT_RNE);
    SPI_I2S_Interrupts_Enable(SPI2, SPI_I2S_INT_RNE);

}
static uint16_t recnt=0,txcnt=0;
void SPI1_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI1, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        SPI_Master_Buffer_Rx[recnt++] = SPI_I2S_Data_Get(SPI1);
    }
}

void SPI2_IRQHandler(void)
{
    if (SPI_I2S_Interrupt_Flag_Status_Get(SPI2, SPI_I2S_INT_FLAG_RNE) == SET)
    {
        SPI_Slave_Buffer_Rx[RxIdx++] = SPI_I2S_Data_Get(SPI2);
                
    }
}
/*
    spi外设相关配置
*/
static void bsp_spi_dma_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_DOUBLELINE_FULLDUPLEX;		//发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;					//主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;			//数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW; 					//时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;		//第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_SOFT;							//硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;			//时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);

    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI1);//NSS 使能


    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    //SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
        SPI_Set_Nss_Level(SPI2, SPI_NSS_LOW);
 
    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}


/*
    功能：配置SPI2为dma接收
*/
static void bps_spi_dma_dma_config(void)
{
    DMA_InitType DMA_InitStructure;

    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);

    DMA_Channel_Enable(DMA_CH1);
    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
}


/*
功能：配置SPI1为dma发送
    
    1. 配置dma
    2. 通道映射
    3. spi 外设的dma发送使能
*/
static void bps_spi_dma_dma_config2(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH2);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH2, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH2, DMA_REMAP_SPI1_TX);

    DMA_Channel_Enable(DMA_CH2);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_TX);
}
/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config3(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH3);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH3, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH3, DMA_REMAP_SPI2_TX);

    DMA_Channel_Enable(DMA_CH3);

    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_TX);
}


/*spi 中断模式接收发送数据测试*/
void bsp_spi_dma_init(void)
{
    //外设时钟使能
    bsp_spi_dma_rcc_cinfig();
    //外设gpio设置
    bsp_spi_dma_gpio_config();
    //中断配置
    bsp_spi_dma_nvic_config();
    //spi外设配置
    bsp_spi_dma_config();
    /* 使能spi外设 */
    bps_spi_dma_dma_config2();
        bps_spi_dma_dma_config3();
    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_dma_test(void)
{
    
//		uint8_t *send= (uint8_t *)SPI_Slave_Buffer_Tx;
//		while(txcnt<32){
//		while (SPI_I2S_Flag_Status_Get(SPI2, SPI_I2S_FLAG_TE) == RESET);
//			SPI_I2S_Data_Transmit(SPI2,send[txcnt++]);
//		}
    while(DMA_Flag_Status_Get(DMA, DMA_CH2_TXCF) == RESET);
        while(DMA_Flag_Status_Get(DMA, DMA_CH3_TXCF) == RESET);

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }

    printf("\r\n");
        
        for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Master_Buffer_Rx[i]);
    }

    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}
```

## spi dma 方式接收，发送数据

### 查询方式

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32

static volatile uint32_t sucessful = 0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                                    0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                                    0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                                    0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40
                                                   };
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                                   0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                                   0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                                   0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90
                                                  };
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];
/*时钟使能
    1.gpio时钟
    2.spi我外设时钟
  3.dma时钟
*/
static void bsp_spi_dma_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);

    /*dma 时钟设置*/
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);

    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
}
/*
    spi gpio配置

*/
static void bsp_spi_dma_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);


    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}

/*
    spi外设相关配置
*/
static void bsp_spi_dma_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_DOUBLELINE_FULLDUPLEX;        //发送模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;                  //主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;          //数据16位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW;                   //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;       //第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_SOFT;                         //硬件NSS
    /* It is recommended that the SPI master mode of the C version chips should not exceed 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;          //时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);

    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI1);//NSS 使能

    /* SPI_SLAVE configuration ------------------------------------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    //SPI_InitStructure.DataDirection = SPI_DIR_SINGLELINE_RX;
    SPI_Initializes(SPI2, &SPI_InitStructure);
    SPI_Set_Nss_Level(SPI2, SPI_NSS_LOW);

    //  SPI_SS_Output_Enable(SPI2);//NSS 使能
    //SPI_CRC_Disable(SPI2);
}

/*
    功能：配置SPI2为dma接收
*/
static void bps_spi_dma_dma_config_SPI2_dma_recv(void)
{
    DMA_InitType DMA_InitStructure;

    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);

    DMA_Channel_Enable(DMA_CH1);
    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
}

/*
功能：配置SPI1为dma发送

    1. 配置dma
    2. 通道映射
    3. spi 外设的dma发送使能
*/
static void bps_spi_dma_dma_config_spi1_dma_send(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH5);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH5, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH5, DMA_REMAP_SPI1_TX);

    DMA_Channel_Enable(DMA_CH5);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_TX);
}
/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config_spi2_dma_send(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH3);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH3, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH3, DMA_REMAP_SPI2_TX);

    DMA_Channel_Enable(DMA_CH3);

    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_TX);
}

/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config_spi1_dma_recv(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH4);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;//外设是数据源
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH4, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH4, DMA_REMAP_SPI1_RX);

    DMA_Channel_Enable(DMA_CH4);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_RX);

}

/*spi 中断模式接收发送数据测试*/
void bsp_spi_dma_init(void)
{
    //外设时钟使能
    bsp_spi_dma_rcc_cinfig();
    //外设gpio设置
    bsp_spi_dma_gpio_config();

    //spi外设配置
    bsp_spi_dma_config();
    //spi dma 外设配置
    bps_spi_dma_dma_config_SPI2_dma_recv();
    bps_spi_dma_dma_config_spi1_dma_send();
    bps_spi_dma_dma_config_spi2_dma_send();
    bps_spi_dma_dma_config_spi1_dma_recv();

    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_dma_test(void)
{

    while (DMA_Flag_Status_Get(DMA, DMA_CH1_TXCF) == RESET);
    while (DMA_Flag_Status_Get(DMA, DMA_CH5_TXCF) == RESET);
    while (DMA_Flag_Status_Get(DMA, DMA_CH3_TXCF) == RESET);
    while (DMA_Flag_Status_Get(DMA, DMA_CH4_TXCF) == RESET);

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }

    printf("\r\n");

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Master_Buffer_Rx[i]);
    }

    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}
```

### 中断方式

```c

#include "n32g430.h"
#include "bsp_spi.h"
#include "stdio.h"
#include "string.h"
#include "bsp_delay.h"
#define BufferSize 32

static volatile uint32_t sucessful = 0;
static uint16_t SPI_Master_Buffer_Tx[BufferSize] = {0x0102, 0x0304, 0x0506, 0x0708, 0x090A, 0x0B0C, 0x0D0E, 0x0F10,
                                                    0x1112, 0x1314, 0x1516, 0x1718, 0x191A, 0x1B1C, 0x1D1E, 0x1F20,
                                                    0x2122, 0x2324, 0x2526, 0x2728, 0x292A, 0x2B2C, 0x2D2E, 0x2F30,
                                                    0x3132, 0x3334, 0x3536, 0x3738, 0x393A, 0x3B3C, 0x3D3E, 0x3F40
                                                   };
static uint16_t SPI_Slave_Buffer_Tx[BufferSize] = {0x5152, 0x5354, 0x5556, 0x5758, 0x595A, 0x5B5C, 0x5D5E, 0x5F60,
                                                   0x6162, 0x6364, 0x6566, 0x6768, 0x696A, 0x6B6C, 0x6D6E, 0x6F70,
                                                   0x7172, 0x7374, 0x7576, 0x7778, 0x797A, 0x7B7C, 0x7D7E, 0x7F80,
                                                   0x8182, 0x8384, 0x8586, 0x8788, 0x898A, 0x8B8C, 0x8D8E, 0x8F90
                                                  };
static uint16_t SPI_Master_Buffer_Rx[BufferSize], SPI_Slave_Buffer_Rx[BufferSize];
/*时钟使能
    1.gpio时钟
    2.spi我外设时钟
  3.dma时钟
*/
static void bsp_spi_dma_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* Enable peripheral clocks --------------------------------------------------*/
    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_SPI1 | RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_GPIOA | RCC_AHB_PERIPH_GPIOB);

    /*dma 时钟设置*/
    RCC_AHB_Peripheral_Clock_Enable(RCC_AHB_PERIPH_DMA);

    //使能复用时钟
    RCC_APB2_Peripheral_Clock_Enable(RCC_APB2_PERIPH_AFIO);
}
/*
    spi gpio配置

*/
static void bsp_spi_dma_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置主设备 master pins: NSS, SCK, MISO and MOSI */

    GPIO_InitStructure.Pin        = GPIO_PIN_5;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.Pin        = GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF2_SPI1;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);

    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.Pin        = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
/*
    spi 中断相关配置
*/
static void bsp_spi_dma_nvic_config(void)
{
    NVIC_InitType NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = DMA_Channel1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = DMA_Channel3_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = DMA_Channel4_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    NVIC_InitStructure.NVIC_IRQChannel = DMA_Channel5_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Initializes(&NVIC_InitStructure);

    //使能外设spi的中断
}

void DMA_Channel1_IRQHandler(void)
{
    if (DMA_Interrupt_Status_Get(DMA, DMA_CH1_INT_TXC) == SET)
    {
        DMA_Interrupt_Status_Clear(DMA, DMA_CH1_INT_TXC);
        sucessful++;
    }
}

void DMA_Channel3_IRQHandler(void)
{
    if (DMA_Interrupt_Status_Get(DMA, DMA_CH3_INT_TXC) == SET)
    {
        DMA_Interrupt_Status_Clear(DMA, DMA_CH3_INT_TXC);
        sucessful++;
    }
}
void DMA_Channel4_IRQHandler(void)
{
    if (DMA_Interrupt_Status_Get(DMA, DMA_CH4_INT_TXC) == SET)
    {
        DMA_Interrupt_Status_Clear(DMA, DMA_CH4_INT_TXC);
        sucessful++;
    }
}
void DMA_Channel5_IRQHandler(void)
{
    if (DMA_Interrupt_Status_Get(DMA, DMA_CH5_INT_TXC) == SET)
    {
        DMA_Interrupt_Status_Clear(DMA, DMA_CH5_INT_TXC);
        sucessful++;
    }
}

/*
    spi外设相关配置
*/
static void bsp_spi_dma_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_DOUBLELINE_FULLDUPLEX;        //全双工模式 3线全双工模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;                  //主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;          //数据8位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_LOW;                   //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;       //第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_SOFT;                         //软件NSS
    /* spi工作频率小于 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;          //时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI1, &SPI_InitStructure);

    SPI_Set_Nss_Level(SPI1, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI1);//NSS 使能输出--这个必须打开

    /* --------------------------SPI_SLAVE configuration ----------------------------*/
    SPI_InitStructure.SpiMode = SPI_MODE_SLAVE;
    SPI_Initializes(SPI2, &SPI_InitStructure);
    SPI_Set_Nss_Level(SPI2, SPI_NSS_LOW);

}


/*
    功能：配置SPI2为dma接收
*/
static void bps_spi_dma_dma_config_SPI2_dma_recv(void)
{
    DMA_InitType DMA_InitStructure;

    DMA_Reset(DMA_CH1);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_HALFWORD;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH1, &DMA_InitStructure);
    DMA_Channel_Request_Remap(DMA_CH1, DMA_REMAP_SPI2_RX);
    DMA_Interrupts_Enable(DMA_CH1, DMA_INT_TXC); //使能dma之前打开中断，使能后打开中断就会配置失败
    DMA_Channel_Enable(DMA_CH1);
    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_RX);
}

/*
功能：配置SPI1为dma发送

    1. 配置dma
    2. 通道映射
    3. spi 外设的dma发送使能
*/
static void bps_spi_dma_dma_config_spi1_dma_send(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH5);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH5, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH5, DMA_REMAP_SPI1_TX);
    DMA_Interrupts_Enable(DMA_CH5, DMA_INT_TXC); //使能dma之前打开中断，使能后打开中断就会配置失败
    DMA_Channel_Enable(DMA_CH5);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_TX);
}
/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config_spi2_dma_send(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH3);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Slave_Buffer_Tx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_DST;
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI2->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH3, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH3, DMA_REMAP_SPI2_TX);

    DMA_Interrupts_Enable(DMA_CH3, DMA_INT_TXC); //使能dma之前打开中断，使能后打开中断就会配置失败
    DMA_Channel_Enable(DMA_CH3);

    SPI_I2S_DMA_Transfer_Enable(SPI2, SPI_I2S_DMA_TX);
}


/*
    spi2 dma 发送数据
*/
static void bps_spi_dma_dma_config_spi1_dma_recv(void)
{
    DMA_InitType DMA_InitStructure;
    //结构体初始化
    DMA_Reset(DMA_CH4);

    /* SPI_MASTER TX DMA config */
    DMA_InitStructure.MemAddr = (uint32_t)&SPI_Master_Buffer_Rx[0];
    DMA_InitStructure.MemDataSize = DMA_MEM_DATA_WIDTH_BYTE;
    DMA_InitStructure.MemoryInc = DMA_MEM_INC_MODE_ENABLE;
    DMA_InitStructure.Direction = DMA_DIR_PERIPH_SRC;//外设是数据源
    DMA_InitStructure.PeriphAddr = (uint32_t)&SPI1->DAT;
    DMA_InitStructure.PeriphDataSize = DMA_PERIPH_DATA_WIDTH_BYTE;
    DMA_InitStructure.PeriphInc = DMA_PERIPH_INC_MODE_DISABLE;
    DMA_InitStructure.BufSize = BufferSize;
    DMA_InitStructure.CircularMode = DMA_CIRCULAR_MODE_DISABLE;
    DMA_InitStructure.Mem2Mem = DMA_MEM2MEM_DISABLE;
    DMA_InitStructure.Priority = DMA_CH_PRIORITY_MEDIUM;
    DMA_Initializes(DMA_CH4, &DMA_InitStructure);

    DMA_Channel_Request_Remap(DMA_CH4, DMA_REMAP_SPI1_RX);
    DMA_Interrupts_Enable(DMA_CH4, DMA_INT_TXC); //使能dma之前打开中断，使能后打开中断就会配置失败
    DMA_Channel_Enable(DMA_CH4);

    SPI_I2S_DMA_Transfer_Enable(SPI1, SPI_I2S_DMA_RX);
}


/*spi 中断模式接收发送数据测试*/
void bsp_spi_dma_init(void)
{
    //外设时钟使能
    bsp_spi_dma_rcc_cinfig();
    //外设gpio设置
    bsp_spi_dma_gpio_config();
    //中断配置
    bsp_spi_dma_nvic_config();
    //spi外设配置
    bsp_spi_dma_config();
    //spi dma 外设配置
    bps_spi_dma_dma_config_SPI2_dma_recv();
    bps_spi_dma_dma_config_spi1_dma_send();
    bps_spi_dma_dma_config_spi2_dma_send();
    bps_spi_dma_dma_config_spi1_dma_recv();

    SPI_ON(SPI1);
    SPI_ON(SPI2);
}

static int Buffercmp(uint16_t *pBuffer1, uint16_t *pBuffer2, uint16_t BufferLength)
{
    while (BufferLength--)
    {
        if (*pBuffer1 != *pBuffer2)
        {
            return 0;
        }

        pBuffer1++;
        pBuffer2++;
    }

    return 1;
}
void bsp_spi_dma_test(void)
{

    for (; 4 > sucessful;)
    {
        printf("wait\r\n");
    }

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Slave_Buffer_Rx[i]);
    }

    printf("\r\n");

    for (int i = 0; i < BufferSize; i++)
    {
        printf("%02x ", SPI_Master_Buffer_Rx[i]);
    }

    printf("\r\n");
    /* Check the received data with the send ones */
    int s = Buffercmp(SPI_Slave_Buffer_Rx, SPI_Master_Buffer_Tx, BufferSize);

    if (s)
    {
        printf("Test PASS!\r\n");
    }
    else
    {
        printf("Test ERR!\r\n");
    }
}
```

### spi flash W25Q128 读写测试

#### bsp_w25qxx.h

```c
#ifndef _BSP_BSP_W25QXX_H_
#define _BSP_BSP_W25QXX_H_
#include "n32g430.h"
#include "stdint.h"
/*

    原理图内部是
    PB12 CS
    PB13 SCLK
    PB14	MISO
    PB15  MOSI
*/

#define NORFLASH_CS(x)      do{ x ? \
                                  GPIO_Pins_Set(GPIOB, GPIO_PIN_12) : \
                                  GPIO_Pins_Reset(GPIOB, GPIO_PIN_12); \
                            }while(0)

/*spi 初始化和cs引脚初始化*/
void bsp_init(void);

//从spi外设写入并读取一个数据
uint8_t spi2_read_write_byte(uint8_t send_data);
//设置spi外设熟速度
void spi2_set_speed(uint8_t speed);
#endif 

```

#### bsp_w25qxx.c

```c
#include "bsp_w25qxx.h"

static void bsp_spi_rcc_cinfig(void)
{
    /* 时钟分频PCLK2 = HCLK/2 */
    RCC_Pclk2_Config(RCC_HCLK_DIV2);

    /* spi 时钟 enable */
    RCC_APB2_Peripheral_Clock_Enable( RCC_APB2_PERIPH_SPI2);

    /* GPIO 外设 时钟 enable */
    RCC_AHB_Peripheral_Clock_Enable( RCC_AHB_PERIPH_GPIOB);
}

static void bsp_spi_gpio_config(void)
{
    GPIO_InitType GPIO_InitStructure;

    GPIO_Structure_Initialize(&GPIO_InitStructure);
    /* 配置从设备 slave pins: NSS, SCK, MISO and MOSI */
    /* Confugure SPI pins as Input Floating */
    GPIO_InitStructure.GPIO_Slew_Rate = GPIO_SLEW_RATE_FAST;
    GPIO_InitStructure.Pin        =   GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
    GPIO_InitStructure.GPIO_Alternate = GPIO_AF1_SPI2;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
    
    GPIO_Structure_Initialize(&GPIO_InitStructure);
    GPIO_InitStructure.Pin          = GPIO_PIN_12 ;
    GPIO_InitStructure.GPIO_Mode    = GPIO_MODE_OUT_PP;
    GPIO_InitStructure.GPIO_Current = GPIO_DS_4MA;
    GPIO_InitStructure.GPIO_Pull = GPIO_PULL_UP;
    GPIO_Peripheral_Initialize(GPIOB, &GPIO_InitStructure);
}
static void bsp_spi_config(void)
{
    SPI_InitType SPI_InitStructure;
    SPI_Initializes_Structure(&SPI_InitStructure);
    SPI_InitStructure.DataDirection = SPI_DIR_DOUBLELINE_FULLDUPLEX;        //全双工模式 3线全双工模式
    SPI_InitStructure.SpiMode       = SPI_MODE_MASTER;                  //主模式
    SPI_InitStructure.DataLen       = SPI_DATA_SIZE_8BITS;          //数据8位宽
    SPI_InitStructure.CLKPOL        = SPI_CLKPOL_HIGH;                   //时钟默认电平是低
    SPI_InitStructure.CLKPHA        = SPI_CLKPHA_SECOND_EDGE;       //第二个边沿采集数据
    SPI_InitStructure.NSS           = SPI_NSS_SOFT;                         //软件NSS
    /* spi工作频率小于 18MHz */
    SPI_InitStructure.BaudRatePres  = SPI_BR_PRESCALER_64;          //时钟分频
    SPI_InitStructure.FirstBit      = SPI_FB_MSB;//MSB
    SPI_InitStructure.CRCPoly       = 7;
    SPI_Initializes(SPI2, &SPI_InitStructure);

    SPI_Set_Nss_Level(SPI2, SPI_NSS_HIGH);
    SPI_SS_Output_Enable(SPI2);//NSS 使能输出--这个必须打开
    SPI_ON(SPI2);

}
void bsp_init(void)
{
    
    bsp_spi_rcc_cinfig();
    bsp_spi_gpio_config();
    bsp_spi_config();
}


uint8_t spi2_read_write_byte(uint8_t send_data)
{
        int x=1000;
        while(RESET ==SPI_I2S_Flag_Status_Get(SPI2,SPI_I2S_FLAG_TE));
        SPI_I2S_Data_Transmit(SPI2, send_data);
        x=1000;
        while(RESET ==SPI_I2S_Flag_Status_Get(SPI2,SPI_I2S_FLAG_RNE));
        uint8_t recv_data = SPI_I2S_Data_Get(SPI2);
    return recv_data;
}

void spi2_set_speed(uint8_t speed)
{
    SPI_SS_Output_Disable(SPI2);
    SPI_BaudRatePres_Config(SPI2,speed);
     SPI_SS_Output_Enable(SPI2);//NSS 使能输出--这个必须打开
    
}



void spi_flash_test()
{
    int x = 0;
        bsp_init();
    norflash_init();
    uint8_t buf[256];

    for(x = 0; x < 256; x++)buf[x] = x;

    norflash_write(buf, 0, 256);
    memset(buf, 0, 256);
    norflash_read(buf, 0, 256);

    for(x = 0; x < 256; x++)
    {
        if(buf[x] != x)break;
    }

    if(x != 256)
    {
        printf("spi flash test fail\r\n");
    }
    else
    {
        printf("spi flash test ok\r\n");
    }
}

```



#### w25qxx.h

```c
/**
 ****************************************************************************************************
 * @file        norflash.h
 * @author      正点原子团队(ALIENTEK)
 * @version     V1.0
 * @date        2021-10-26
 * @brief       NOR FLASH(25QXX) 驱动代码
 * @license     Copyright (c) 2020-2032, 广州市星翼电子科技有限公司
 ****************************************************************************************************
 * @attention
 *
 * 实验平台：正点原子 F407电机开发板
 * 在线视频：www.yuanzige.com
 * 技术论坛：http://www.openedv.com/forum.php
 * 公司网址：www.alientek.com
 * 购买地址：zhengdianyuanzi.tmall.com
 *
 * 修改说明
 * V1.0 20211026
 * 第一次发布
 *
 ****************************************************************************************************
 */

#ifndef __norflash_H
#define __norflash_H

#include "main.h"


/*
    2022-7-27 经过测试 华邦的 W25Q256JV   32M 字节 容量的spi flash没有问题  spi配置是  上升沿采集数据 ---> CPOL =0 CPOA=0  或者是 CPOL=1 CPOA=1   hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
                                        华邦的  W25Q16JVSSIQ 2M 字节 容量的spi flash没有问题 
    
*/






/* SPI总线速度设置 */
#define SPI_SPEED_2         0
#define SPI_SPEED_4         1
#define SPI_SPEED_8         2
#define SPI_SPEED_16        3
#define SPI_SPEED_32        4
#define SPI_SPEED_64        5
#define SPI_SPEED_128       6
#define SPI_SPEED_256       7


/******************************************************************************************/
/* NORFLASH 片选 引脚 定义 */

#define NORFLASH_CS_GPIO_PORT           GPIOA
#define NORFLASH_CS_GPIO_PIN            GPIO_PIN_2
#define NORFLASH_CS_GPIO_CLK_ENABLE()   do{ __HAL_RCC_GPIOA_CLK_ENABLE(); }while(0)   /* PI口时钟使能 */

/******************************************************************************************/
//spi外设选择
//extern SPI_HandleTypeDef hspi1;
#define HSPI hspi1

/* NORFLASH 片选信号 */


/* FLASH芯片列表 */
#define W25Q80      0XEF13          /* W25Q80   芯片ID */
#define W25Q16      0XEF14          /* W25Q16   芯片ID */
#define W25Q32      0XEF15          /* W25Q32   芯片ID */
#define W25Q64      0XEF16          /* W25Q64   芯片ID */
#define W25Q128     0XEF17          /* W25Q128  芯片ID */
#define W25Q256     0XEF18          /* W25Q256  芯片ID */
#define BY25Q64     0X6816          /* BY25Q64  芯片ID */
#define BY25Q128    0X6817          /* BY25Q128 芯片ID */
#define NM25Q64     0X5216          /* NM25Q64  芯片ID */
#define NM25Q128    0X5217          /* NM25Q128 芯片ID */

extern uint16_t norflash_TYPE;      /* 定义FLASH芯片型号 */
 
/* 指令表 */
#define FLASH_WriteEnable           0x06 
#define FLASH_WriteDisable          0x04 
#define FLASH_ReadStatusReg1        0x05 
#define FLASH_ReadStatusReg2        0x35 
#define FLASH_ReadStatusReg3        0x15 
#define FLASH_WriteStatusReg1       0x01 
#define FLASH_WriteStatusReg2       0x31 
#define FLASH_WriteStatusReg3       0x11 
#define FLASH_ReadData              0x03 
#define FLASH_FastReadData          0x0B 
#define FLASH_FastReadDual          0x3B 
#define FLASH_FastReadQuad          0xEB  
#define FLASH_PageProgram           0x02 
#define FLASH_PageProgramQuad       0x32 
#define FLASH_BlockErase            0xD8 
#define FLASH_SectorErase           0x20 
#define FLASH_ChipErase             0xC7 
#define FLASH_PowerDown             0xB9 
#define FLASH_ReleasePowerDown      0xAB 
#define FLASH_DeviceID              0xAB 
#define FLASH_ManufactDeviceID      0x90 
#define FLASH_JedecDeviceID         0x9F 
#define FLASH_Enable4ByteAddr       0xB7
#define FLASH_Exit4ByteAddr         0xE9
#define FLASH_SetReadParam          0xC0 
#define FLASH_EnterQPIMode          0x38
#define FLASH_ExitQPIMode           0xFF

/* 静态函数 */
static void norflash_wait_busy(void);               /* 等待空闲 */
static void norflash_send_address(uint32_t address);/* 发送地址 */
static void norflash_write_page(uint8_t *pbuf, uint32_t addr, uint16_t datalen);    /* 写入page */
static void norflash_write_nocheck(uint8_t *pbuf, uint32_t addr, uint16_t datalen); /* 写flash,不带擦除 */

/* 普通函数 */
void norflash_init(void);                   /* 初始化25QXX */
uint16_t norflash_read_id(void);            /* 读取FLASH ID */
void norflash_write_enable(void);           /* 写使能 */
uint8_t norflash_read_sr(uint8_t regno);    /* 读取状态寄存器 */
void norflash_write_sr(uint8_t regno,uint8_t sr);   /* 写状态寄存器 */

void norflash_erase_chip(void);             /* 整片擦除 */
void norflash_erase_sector(uint32_t saddr); /* 扇区擦除 */
void norflash_read(uint8_t *pbuf, uint32_t addr, uint16_t datalen);     /* 读取flash */
void norflash_write(uint8_t *pbuf, uint32_t addr, uint16_t datalen);    /* 写入flash */

#endif

```



#### w25qxx.c

```c
/**
 ****************************************************************************************************
 * @file        norflash.c
 * @author      正点原子团队(ALIENTEK)
 * @version     V1.0
 * @date        2021-10-26
 * @brief       NOR FLASH(25QXX) 驱动代码
 * @license     Copyright (c) 2020-2032, 广州市星翼电子科技有限公司
 ****************************************************************************************************
 * @attention
 *
 * 实验平台：正点原子 F407电机开发板
 * 在线视频：www.yuanzige.com
 * 技术论坛：http://www.openedv.com/forum.php
 * 公司网址：www.alientek.com
 * 购买地址：zhengdianyuanzi.tmall.com
 *
 * 修改说明
 * V1.0 20211026
 * 第一次发布
 *
 ****************************************************************************************************
 */


#include "w25qxx.h"
#include "stdio.h"
#include "bsp_w25qxx.h"
uint16_t g_norflash_type = NM25Q128;     /* 默认是NM25Q128 */
/*需要移植的代码：spi数据收发函数*/

/**
* @brief SPI2 速度设置函数
* @note SPI2 时钟选择来自 APB1, 即 PCLK1, 为 42Mhz
* SPI 速度 = PCLK1 / 2^(speed + 1)
* @param speed : SPI2 时钟分频系数
取值为 SPI_BAUDRATEPRESCALER_2~SPI_BAUDRATEPRESCALER_2 256
* @retval 无
*/
//void spi2_set_speed(uint8_t speed)
//{
//    assert_param(IS_SPI_BAUDRATE_PRESCALER(speed));/* 判断有效性 */
//    __HAL_SPI_DISABLE(&HSPI); /* 关闭 SPI */
//    HSPI.Instance->CR1 &= 0xFFC7; /* 位 3-5 清零，用来设置波特率 */
//    HSPI.Instance->CR1 |= speed << 3; /* 设置 SPI 速度 */
//    __HAL_SPI_ENABLE(&HSPI); /* 使能 SPI */
//}

/**
 * @brief       初始化SPI NOR FLASH
 * @param       无
 * @retval      无
 */
void norflash_init(void)
{

    //spi2_set_speed(SPI_SPEED_4);            /* SPI2 切换到高速状态 21Mhz */
        uint8_t temp=0;
    g_norflash_type = norflash_read_id();   /* 读取FLASH ID. */

    if (g_norflash_type == W25Q256)         /* SPI FLASH为W25Q256, 必须使能4字节地址模式 */
    {
        temp = norflash_read_sr(3);         /* 读取状态寄存器3，判断地址模式 */

        if ((temp & 0x01) == 0)             /* 如果不是4字节地址模式,则进入4字节地址模式 */
        {
            norflash_write_enable();        /* 写使能 */
            temp |= 1 << 1;                 /* ADP=1, 上电4位地址模式 */
            norflash_write_sr(3, temp);     /* 写SR3 */

            NORFLASH_CS(0);
            spi2_read_write_byte(FLASH_Enable4ByteAddr);    /* 使能4字节地址指令 */
            NORFLASH_CS(1);
        }
    }

   // printf("ID:%x\r\n", g_norflash_type);
}

/**
 * @brief       等待空闲
 * @param       无
 * @retval      无
 */
static void norflash_wait_busy(void)
{
    while ((norflash_read_sr(1) & 0x01) == 0x01);   /* 等待BUSY位清空 */
}

/**
 * @brief       25QXX写使能
 *   @note      将S1寄存器的WEL置位
 * @param       无
 * @retval      无
 */
void norflash_write_enable(void)
{
    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_WriteEnable);   /* 发送写使能 */
    NORFLASH_CS(1);
}

/**
 * @brief       25QXX发送地址
 *   @note      根据芯片型号的不同, 发送24ibt / 32bit地址
 * @param       address : 要发送的地址
 * @retval      无
 */
static void norflash_send_address(uint32_t address)
{
    if (g_norflash_type == W25Q256) /* 只有W25Q256支持4字节地址模式 */
    {
        spi2_read_write_byte((uint8_t)((address) >> 24)); /* 发送 bit31 ~ bit24 地址 */
    }

    spi2_read_write_byte((uint8_t)((address) >> 16));   /* 发送 bit23 ~ bit16 地址 */
    spi2_read_write_byte((uint8_t)((address) >> 8));    /* 发送 bit15 ~ bit8  地址 */
    spi2_read_write_byte((uint8_t)address);             /* 发送 bit7  ~ bit0  地址 */
}

/**
 * @brief       读取25QXX的状态寄存器，25QXX一共有3个状态寄存器
 *   @note      状态寄存器1：
 *              BIT7  6   5   4   3   2   1   0
 *              SPR   RV  TB BP2 BP1 BP0 WEL BUSY
 *              SPR:默认0,状态寄存器保护位,配合WP使用
 *              TB,BP2,BP1,BP0:FLASH区域写保护设置
 *              WEL:写使能锁定
 *              BUSY:忙标记位(1,忙;0,空闲)
 *              默认:0x00
 *
 *              状态寄存器2：
 *              BIT7  6   5   4   3   2   1   0
 *              SUS   CMP LB3 LB2 LB1 (R) QE  SRP1
 *
 *              状态寄存器3：
 *              BIT7      6    5    4   3   2   1   0
 *              HOLD/RST  DRV1 DRV0 (R) (R) WPS ADP ADS
 *
 * @param       regno: 状态寄存器号，范:1~3
 * @retval      状态寄存器值
 */
uint8_t norflash_read_sr(uint8_t regno)
{
    uint8_t byte = 0, command = 0;

    switch (regno)
    {
        case 1:
            command = FLASH_ReadStatusReg1;  /* 读状态寄存器1指令 */
            break;

        case 2:
            command = FLASH_ReadStatusReg2;  /* 读状态寄存器2指令 */
            break;

        case 3:
            command = FLASH_ReadStatusReg3;  /* 读状态寄存器3指令 */
            break;

        default:
            command = FLASH_ReadStatusReg1;
            break;
    }

    NORFLASH_CS(0);
    spi2_read_write_byte(command);      /* 发送读寄存器命令 */
    byte = spi2_read_write_byte(0xFF);  /* 读取一个字节 */
    NORFLASH_CS(1);

    return byte;
}

/**
 * @brief       写25QXX状态寄存器
 *   @note      寄存器说明见norflash_read_sr函数说明
 * @param       regno: 状态寄存器号，范:1~3
 * @param       sr   : 要写入状态寄存器的值
 * @retval      无
 */
void norflash_write_sr(uint8_t regno, uint8_t sr)
{
    uint8_t command = 0;

    switch (regno)
    {
        case 1:
            command = FLASH_WriteStatusReg1;  /* 写状态寄存器1指令 */
            break;

        case 2:
            command = FLASH_WriteStatusReg2;  /* 写状态寄存器2指令 */
            break;

        case 3:
            command = FLASH_WriteStatusReg3;  /* 写状态寄存器3指令 */
            break;

        default:
            command = FLASH_WriteStatusReg1;
            break;
    }

    NORFLASH_CS(0);
    spi2_read_write_byte(command);  /* 发送读寄存器命令 */
    spi2_read_write_byte(sr);       /* 写入一个字节 */
    NORFLASH_CS(1);
}

/**
 * @brief       读取芯片ID
 * @param       无
 * @retval      FLASH芯片ID
 *   @note      芯片ID列表见: norflash.h, 芯片列表部分
 */
uint16_t norflash_read_id(void)
{
    uint16_t deviceid;

    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_ManufactDeviceID);   /* 发送读 ID 命令 */
    spi2_read_write_byte(0);    /* 写入一个字节 */
    spi2_read_write_byte(0);
    spi2_read_write_byte(0);
    deviceid = spi2_read_write_byte(0xFF) << 8;     /* 读取高8位字节 */
    deviceid |= spi2_read_write_byte(0xFF);         /* 读取低8位字节 */
    NORFLASH_CS(1);

    return deviceid;
}

/**
 * @brief       读取SPI FLASH
 *   @note      在指定地址开始读取指定长度的数据
 * @param       pbuf    : 数据存储区
 * @param       addr    : 开始读取的地址(最大32bit)
 * @param       datalen : 要读取的字节数(最大65535)
 * @retval      无
 */
void norflash_read(uint8_t *pbuf, uint32_t addr, uint16_t datalen)
{
    uint16_t i;

    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_ReadData);       /* 发送读取命令 */
    norflash_send_address(addr);                /* 发送地址 */

    for (i = 0; i < datalen; i++)
    {
        pbuf[i] = spi2_read_write_byte(0xFF);   /* 循环读取 */
    }

    NORFLASH_CS(1);
}

/**
 * @brief       SPI在一页(0~65535)内写入少于256个字节的数据
 *   @note      在指定地址开始写入最大256字节的数据
 * @param       pbuf    : 数据存储区
 * @param       addr    : 开始写入的地址(最大32bit)
 * @param       datalen : 要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!
 * @retval      无
 */
static void norflash_write_page(uint8_t *pbuf, uint32_t addr, uint16_t datalen)
{
    uint16_t i;

    norflash_write_enable();    /* 写使能 */

    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_PageProgram);    /* 发送写页命令 */
    norflash_send_address(addr);                /* 发送地址 */

    for (i = 0; i < datalen; i++)
    {
        spi2_read_write_byte(pbuf[i]);          /* 循环读取 */
    }

    NORFLASH_CS(1);
    norflash_wait_busy();       /* 等待写入结束 */
}

/**
 * @brief       无检验写SPI FLASH
 *   @note      必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!
 *              具有自动换页功能
 *              在指定地址开始写入指定长度的数据,但是要确保地址不越界!
 *
 * @param       pbuf    : 数据存储区
 * @param       addr    : 开始写入的地址(最大32bit)
 * @param       datalen : 要写入的字节数(最大65535)
 * @retval      无
 */
static void norflash_write_nocheck(uint8_t *pbuf, uint32_t addr, uint16_t datalen)
{
    uint16_t pageremain;
    pageremain = 256 - addr % 256;  /* 单页剩余的字节数 */

    if (datalen <= pageremain)      /* 不大于256个字节 */
    {
        pageremain = datalen;
    }

    while (1)
    {
        /* 当写入字节比页内剩余地址还少的时候, 一次性写完
         * 当写入直接比页内剩余地址还多的时候, 先写完整个页内剩余地址, 然后根据剩余长度进行不同处理
         */
        norflash_write_page(pbuf, addr, pageremain);

        if (datalen == pageremain)      /* 写入结束了 */
        {
            break;
        }
        else     /* datalen > pageremain */
        {
            pbuf += pageremain;         /* pbuf指针地址偏移,前面已经写了pageremain字节 */
            addr += pageremain;         /* 写地址偏移,前面已经写了pageremain字节 */
            datalen -= pageremain;      /* 写入总长度减去已经写入了的字节数 */

            if (datalen > 256)          /* 剩余数据还大于一页,可以一次写一页 */
            {
                pageremain = 256;       /* 一次可以写入256个字节 */
            }
            else     /* 剩余数据小于一页,可以一次写完 */
            {
                pageremain = datalen;   /* 不够256个字节了 */
            }
        }
    }
}

/**
 * @brief       写SPI FLASH
 *   @note      在指定地址开始写入指定长度的数据, 该函数带擦除操作!
 *              SPI FLASH 一般是: 256个字节为一个Page, 4Kbytes为一个Sector, 16个扇区为1个Block
 *              擦除的最小单位为Sector.
 *
 * @param       pbuf    : 数据存储区
 * @param       addr    : 开始写入的地址(最大32bit)
 * @param       datalen : 要写入的字节数(最大65535)
 * @retval      无
 */
uint8_t g_norflash_buf[4096];   /* 扇区缓存 */

void norflash_write(uint8_t *pbuf, uint32_t addr, uint16_t datalen)
{
    uint32_t secpos;
    uint16_t secoff;
    uint16_t secremain;
    uint16_t i;
    uint8_t *norflash_buf;

    norflash_buf = g_norflash_buf;
    secpos = addr / 4096;       /* 扇区地址 */
    secoff = addr % 4096;       /* 在扇区内的偏移 */
    secremain = 4096 - secoff;  /* 扇区剩余空间大小 */

    //printf("ad:%X,nb:%X\r\n", addr, datalen); /* 测试用 */
    if (datalen <= secremain)
    {
        secremain = datalen;    /* 不大于4096个字节 */
    }

    while (1)
    {
        norflash_read(norflash_buf, secpos * 4096, 4096);   /* 读出整个扇区的内容 */

        for (i = 0; i < secremain; i++)   /* 校验数据 */
        {
            if (norflash_buf[secoff + i] != 0XFF)
            {
                break;      /* 需要擦除, 直接退出for循环 */
            }
        }

        if (i < secremain)   /* 需要擦除 */
        {
            norflash_erase_sector(secpos);  /* 擦除这个扇区 */

            for (i = 0; i < secremain; i++)   /* 复制 */
            {
                norflash_buf[i + secoff] = pbuf[i];
            }

            norflash_write_nocheck(norflash_buf, secpos * 4096, 4096);  /* 写入整个扇区 */
        }
        else        /* 写已经擦除了的,直接写入扇区剩余区间. */
        {
            norflash_write_nocheck(pbuf, addr, secremain);  /* 直接写扇区 */
        }

        if (datalen == secremain)
        {
            break;  /* 写入结束了 */
        }
        else        /* 写入未结束 */
        {
            secpos++;               /* 扇区地址增1 */
            secoff = 0;             /* 偏移位置为0 */

            pbuf += secremain;      /* 指针偏移 */
            addr += secremain;      /* 写地址偏移 */
            datalen -= secremain;   /* 字节数递减 */

            if (datalen > 4096)
            {
                secremain = 4096;   /* 下一个扇区还是写不完 */
            }
            else
            {
                secremain = datalen;/* 下一个扇区可以写完了 */
            }
        }
    }
}

/**
 * @brief       擦除整个芯片
 *   @note      等待时间超长...
 * @param       无
 * @retval      无
 */
void norflash_erase_chip(void)
{
    norflash_write_enable();    /* 写使能 */
    norflash_wait_busy();       /* 等待空闲 */
    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_ChipErase);  /* 发送读寄存器命令 */
    NORFLASH_CS(1);
    norflash_wait_busy();       /* 等待芯片擦除结束 */
}

/**
 * @brief       擦除一个扇区
 *   @note      注意,这里是扇区地址,不是字节地址!!
 *              擦除一个扇区的最少时间:150ms
 *
 * @param       saddr : 扇区地址 根据实际容量设置
 * @retval      无
 */
void norflash_erase_sector(uint32_t saddr)
{
    //printf("fe:%x\r\n", saddr);   /* 监视falsh擦除情况,测试用 */
    saddr *= 4096;
    norflash_write_enable();        /* 写使能 */
    norflash_wait_busy();           /* 等待空闲 */

    NORFLASH_CS(0);
    spi2_read_write_byte(FLASH_SectorErase);    /* 发送写页命令 */
    norflash_send_address(saddr);   /* 发送地址 */
    NORFLASH_CS(1);
    norflash_wait_busy();           /* 等待扇区擦除完成 */
}
```
